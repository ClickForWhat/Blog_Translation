*本文档译自 gamedevelopment.tutsplus.com 的 "Game Engine Development" 专栏文章，作者 David Davidović*


## 概述 - *Overview*
----
你可能听说过面向数据的游戏引擎设计，这是一个相对较新的概念，提出了与传统面向对象不同的思维方式。在这篇文章中，我将解释 *DOD* 是什么，以及为什么一些游戏引擎开发者认为它可以获得惊人的性能提升。


## 一点简短的历史 - *A Bit of History*
----
在游戏开发的历史早期，游戏及其引擎都是用老式语言（如C）编写的。它们是一种针对性很强的产品，从缓慢的硬件中多压榨出一个时钟周期是当时的首要任务。在大多数情况下，只有少数人精通一款游戏的代码，他们对整个代码库烂熟于心。他们所使用的工具能够很好地为他们服务，而C能够提供性能上的优势，让他们能够最大限度地利用CPU，因为当时这些游戏仍然受到CPU的限制，需要把画面画进自己的帧缓冲区，这是非常重要的一点。

随着图形处理器（GPU，它可以对三角形、*texel*、像素等进行数字运算）的出现，我们开始减少对CPU的依赖。与此同时，游戏行业也在稳步增长：越来越多的人想要玩更多的游戏，这反过来又催生了越来越多的团队聚集在一起开发游戏。

![[Moore.png]]
<center>摩尔定律表明，硬件的增长是指数级的，而不是线性的：这意味着每隔几年，我们在一块电路板上可以容纳的晶体管数量不会以恒定的数量变化，而是会翻倍</center>

更大的团队需要更好的合作。不久之后，带有复杂关卡、AI、剔除和渲染逻辑的游戏引擎对程序员的要求更加严格，而他们选择的武器是面向对象设计。

正如 *Paul Graham* 曾经说过的：”*在大公司，软件往往是由大型的（且经常变化的）平庸的程序员团队编写的。面向对象编程对这些程序员施加了一种规则，以防止他们中的任何一个人造成太大的破坏。*“

不管我们喜欢与否，在某种程度上，这是事实。更大的公司开始做更大更好的游戏，随着标准化工具的出现，致力于游戏开发的程序员们成为更容易被换掉的”部件“。某些开发者的突出特点变得越来越不重要了。


## 面向对象的问题 - *Problems With Object-Oriented Design*
----
虽然面向对象设计是一个很好的概念，它可以帮助开发人员在大型项目（如游戏）中创建多个抽象层，并让每个人都在他们的层上工作，而不必关心底层的实现细节，但它一定会给我们带来一些困扰。

我们看到并行编程正在爆发式增长，程序员试图利用所有可用的处理器核心，以提供惊人的计算速度。与此同时，游戏场景变得越来越复杂，如果我们想要跟上这一趋势，并仍然提供玩家期望的帧数，我们也需要这样做。通过使用我们手头上所有提高速度的手段，我们可以为全新的可能性打开大门：例如，使用CPU时间来减少发送到GPU的数据数量。

在面向对象编程中，你将状态保存在对象中，如果希望从多个线程处理它，则需要引入同步原语等概念。对于所做的每个虚函数调用，都意味着一个间接调用。以面向对象的方式编写的代码所生成的内存访问模式可能非常糟糕，*Mike Acton* （*Insomniac Games*，前 *Rockstar Games* 员工）曾用[一组很棒的幻灯片](http://macton.smugmug.com/gallery/8936708_T6zQX#!i=593428032&k=DGbc4gm)解释了一个例子。

无独有偶，卡内基梅隆大学教授 *Robert Harper* 也这样说到：”面向对象编程是……（此处省略）。从本质上讲，它既反模块化又反并行，因此不适合现代CS课程。“

像这样谈论 *OOP* 是很棘手的，因为 *OOP* 包含了大量的属性，并不是每个人都同意 *OOP* 的思想。从这个意义上说，我主要谈论的是由C++实现的面向对象编程，因为这是目前在游戏引擎世界中占主导地位的语言以及范式。

所以，现在我们知道游戏需要变得并行，因为CPU总是可以（但不必）做更多的工作，并且花费周期等待GPU完成处理完全是浪费。我们还知道，常见的 *OO* 类设计方法要求我们引入代价高昂的锁竞争，同时，在意想不到的情况下，还可能会缓存失效或导致不必要的分支开销（代价可能很高！）

![[utilization.png]]
<center>如果我们不充分利用多核，即使硬件变得更好（拥有更多内核），我们也只会继续使用相同程度的CPU资源。但与此同时，我们正将GPU推向极限，因为从设计上讲，它是并行的，并且能够同时承担任何数量的工作。这可能会干扰我们在硬件上为玩家提供最佳体验的任务，因为我们显然没有充分发挥它的潜力。</center>

这就提出了一个问题：我们是否应该彻底反思我们的编程范式？


## 开始面向数据设计 - *Enter：Data-Oriented Design*
----
这种方法的一些支持者将其称为面向数据的设计，但事实是，这个概念在被称为”面向数据的设计“之前就已经存在了。它的基本前提很简单：**围绕数据结构建构代码，并根据围绕这些结构的操作描述你想要实现的目标**。

我们以前都听过这种说法：Linux和Git的创造者 *Linus Torvalds* 在Git邮件列表中说，他是”围绕数据设计代码，而不是反过来“的强烈支持者，并将其视为Git成功的原因之一。他甚至声称，好程序员和坏程序员的区别在于TA是担心数据结构，还是仅仅是代码本身。

这个目标乍一看似乎违反直觉，因为它需要你把你的思维模式颠倒过来。但是我们可以这样思考：游戏在运行时能够捕捉到所有用户的输入，并且所有重性能的部分不依赖于外部因素，如网络或进程间通信。众所周知，游戏会处理用户事件（鼠标移动，操纵杆按钮按下等）和当前游戏状态，并将这些数据混合成一组新数据，例如，发送到GPU的批量数据，发送到声卡的音频样本数据，以及新的游戏状态。

这种“数据混合”可以由更小更具体的过程组成。动画系统获取下一个关键帧数据和当前状态，并产生一个新的状态。粒子系统采用其当前状态（粒子位置、速度等）和时间递进来产生一个新状态。而剔除算法可视为选用一组候选的渲染对象，输出一组数量更少的渲染对象。游戏引擎中的几乎所有内容都可以被视为操纵数据块以产生另一个数据块。

处理器更喜欢数据的局部性和缓存的高利用。因此，在面向数据的设计中，我们倾向于尽可能地将所有内容组织在大型同构数组中，并且在可能的情况下使用运行良好的、缓存一致的蛮力算法来取代可能更花里胡哨的算法（后者具有更好的时间复杂度，但可能受其所工作的硬件的架构限制）。

当每帧都（或每帧多次）执行时，这可能会带来巨大的性能提升。例如，*Scalyr* 的工作人员报告说，他们使用精心编写的暴力线性扫描（听起来有点傻），能以20GB/秒的速度搜索日志文件。

![[objects.png]]
<center>当我们处理对象时，我们必须将它们视为“黑盒”并调用它们的方法，这些方法反过来访问数据并为我们提供我们想要的东西（或做出我们想要的更改）。这对于可维护性非常有用，但不知道数据是如何排布的可能会对性能造成不利影响。</center>


## 一些例子 - *Examples*
----
面向数据的设计让我们思考所有的数据，所以让我们做一些与众不同的事情。考虑以下代码：

```C++
void MyEngine::queueRenderables() {
for (auto it = mRenderables.begin(); it != mRenderables.end(); ++it) {
	if ((*it)->isVisible()) {
		queueRenderable(*it);
	}
}
```

虽然简化了很多，但这种常见模式在面向对象的游戏引擎中很常见。然而如果很多渲染对象实际上是不可见的，我们就会遇到很多错误的分支预测，这会导致处理器丢弃一些指令，这些指令是CPU预期可能会执行的那些分支。

对于一些小场景，这显然不是问题。但是，你做了多少次类似的事情？不仅仅是在收集渲染队列的时候，还有在迭代场景灯光、分割阴影贴图、空间划分，又或者是在AI和动画更新之类的地方。将你在整个场景中所做的所有事情相乘，看看你消耗了多少时钟周期，再算算你的处理器还有多少时间来提交所有的GPU *batches* 来稳住120FPS，你将会发现这些微小事情的影响将究极放大。

当然，如果要一名开发Web应用的开发者也要考虑到这种很小的细微优化，那就太搞了。但我们知道游戏是实时系统，资源限制非常严格，所以这种考虑对我们来说并不是错误的。

为了避免糟糕的情况发生，让我们以另一种方式思考：如果我们在引擎中保留可见渲染列表会怎样？当然，我们会牺牲 `myrenable->hide()` 的简洁语法，并违反相当多的 *OOP* 原则，但我们可以这样做：

```C++
void MyEngine::queueRenderables() {
	for (auto it = mVisibleRenderables.begin(); it != mVisibleRenderables.end(); ++it) {
		queueRenderable(*it);
	}
}
```

万岁！不会有错误的分支预测，并且假设 `mVisibleRenderables` 是一个实现良好的 `std::vector`（它是一个连续数组），我们也可以用一个快速的 `memcpy` 调用来覆写（可能需要对数据结构进行一些额外的更新）。

现在，你可能会批评我这些代码示例的蹩脚之处，而且你的观点是正确的：这实在是太过简化了。但说实话，我还没摸到皮毛呢。思考数据结构和它们之间的关系为我们打开了许多我们以前没有考虑过的可能性。接下来让我们来看看其中的一些可能性。


## 并行化和向量化 - *Parallelization and Vectorization*
----
如果我们有简单、定义明确的函数，这些函数对大数据块进行操作，并以此作为处理的基本单元，那么很容易生成4个、8个或16个工作线程，并为每个线程提供一段数据，以使所有CPU核心保持忙碌。没有互斥锁、原子操作或者锁竞争，一旦需要数据，只需连接所有线程并等待它们完成。如果你需要并行排序数据（这是非常频繁的任务——在准备数据发送到GPU时），你必须从不同的角度考虑这个问题，[这些幻灯片](http://macton.smugmug.com/gallery/9114809_C9awM#!i=607513208&k=xqWYf)可能会有所帮助。

额外的好处是，在一个线程中， 你还可以使用 *SIMD* 指令（如 *SSE* / *SSE2* / *SSE3*）来实现额外的速度提升。有时，你只能通过以不同的方式放置数据来实现这一点，例如以 *structure-of-arrays*（*SoA*）的方式放置向量数组（比如 `XXX...YYY...ZZZ...`），而不是传统的 *array-of-structures*（*AoS*，比如 `XYZXYZXYZ...`）。我只是粗略地介绍一下；你可以在下面的扩展阅读部分找到更多信息。

![[parallel.png]]
<center>当我们的算法直接处理数据时，并行化变得很简单，而且我们还可以避免一些速度上的缺点。</center>


## 更容易的单元测试 - *Unit Testing You Didn't Know Was Possible*
----
不产生外部影响的简单函数使它们很容易进行单元测试。这在 *regression test* 中尤其方便轻松切换你想要的算法。

例如，你可以为剔除算法构建一个测试套件，设置一个编排好的环境，并准确测量它的执行情况。当你设计一个新的剔除算法时，你可以再次运行相同的测试，不加任何更改。你可以测量性能和正确性，因此你可以随时对算法进行评估。

当你更深入地使用面向数据的设计方法时，你会发现测试游戏引擎的各个方面变得越来越容易。


## 将类和对象与数据相结合 - *Combining Classes and Objects With Monolithic Data*
----
面向数据的设计并不意味着与面向对象编程相冲突，只是它的一些思想有些不同。因此，你可以非常巧妙地使用来自面向数据的设计的想法，并且仍然不失你所习惯的大多数抽象和思考模型。

例如，看看 [*OGRE* 2.0 版本的工作](http://www.ogre3d.org/forums/viewforum.php?f=25)： *Matias Goldberg* 选择将数据存储在大型同构数组中，并具有遍历整个数组的函数，而不是只处理一个数据，以加快 *OGRE* 的速度。根据一项 *Benchmark* 测试表明（他承认这非常不公平，但所衡量的性能优势不可能仅仅是因为这一点），它现在的工作速度快了三倍。他不仅保留了许多旧的、熟悉的类抽象，而且并不需要完全重写API。


## 这实用吗？ - *Is It Practical?*
----
有许多证据表明，以这种思想为指导的游戏引擎能够并且将会被开发出来。

[*Molecular Engine* 的开发博客](http://molecularmusings.wordpress.com/)有一个名为《面向数据的设计冒险》的系列，其中包含了很多有用的建议，关于 *DOD* 在哪些方面得到了很好的应用。

[*DICE* 似乎对面向数据的设计很感兴趣](http://www.frostbite.com/2011/04/culling-the-battlefield-data-oriented-design-in-practice/)，因为他们在寒霜引擎的剔除系统中使用了这种设计（而且还获得了显著的加速!）他们的[其他一些幻灯片](http://www.slideshare.net/DICEStudio/a-step-towards-data-orientation)还包括在AI子系统中使用面向数据的设计，也值得一看。

除此之外，像前面提到的 *Mike Acton* 这样的开发者似乎也接受了这一概念。有一些 *Benchmark* 证明它确实在性能上获得了很大的提升，但我在相当长一段时间内没有看到很多面向数据的设计方面的动向了。当然，这或许只是一时的潮流，但提出它的动机似乎非常合乎逻辑。在这个行业（以及任何其他软件开发行业）中肯定有很多历史惯性，所以这也可能会阻碍这种哲学的大规模应用。当然，也可能 *DOD* 并没有看上去的那么美好。你怎么看？欢迎提出意见！


## 扩展阅读 - *Further Reading*
----
1.  [Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP)](http://gamesfromwithin.com/data-oriented-design)  
2.  [Introduction to Data Oriented Design (DICE)](http://dice.se/publications/introduction-to-data-oriented-design/)
3.  [A rather nice discussion on Stack Overflow](http://stackoverflow.com/questions/1641580/what-is-data-oriented-design) 
4.  [An online book by Richard Fabian explaining a lot of the concepts](http://www.dataorienteddesign.com/dodmain/dodmain.html) 
5.  [A benchmark showing other side of the story, a seemingly counter-intuitive result](https://rcl-rs-vvg.blogspot.com/2011/04/measuring-benefits-of-data-oriented.html)
6.  [Mike Acton's review of OgreNode.cpp, revealing some common OOP game engine development pitfalls](https://www.bounceapp.com/116414)
