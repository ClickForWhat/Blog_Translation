[流水线](https://en.algorithmica.org/hpc/pipelining/)通过并发执行指令（的不同部分）来隐藏它们的延迟，但是这也会产生潜在的危险，通常把它叫做*流水线冒险*，即下一条指令不能在下一个时钟周期中执行的情况。

这有多种可能发生的方式：

+ 当两个或多个指令需要 CPU 的同一部分（例如，执行单元）时，就会发生*结构冒险*。
+ 当必须等待另一条指令计算出所需操作数时，就会发生*数据冒险*。
+ 当 CPU 无法判断下一步需要执行哪条指令时，就会发生*控制冒险*。

唯一解决冒险的办法是产生*流水线停顿*：停止前面所有阶段的进度，直到阻塞的原因消失。这导致流水线中产生了“泡泡”——类似于流体管道中的气泡——执行单元处于空闲，而且这种状态将随时间沿管道传播。

![[bubble.png]]

不同的冒险有不同的惩罚：

+ 在结构冒险中，你必须等待（通常是一个周期），直到执行单元准备好。它们是性能的基本瓶颈，无法避免，你必须围绕它们进行设计。
+ 在数据冒险中，你必须等待计算所需的数据（关键路径的延迟）。你可以通过重构计算步骤，缩短关键路径，来解决数据冒险。
+ 在控制冒险时，你通常必须刷新整个流水线并重新开始，浪费整整 15-20 个周期。它们可以通过删除分支或使其可预测来解决，这样 CPU 可以有效地推测接下来要执行的内容。

由于它们对性能有非常不同的影响，我们将以相反的顺序，从更严重的影响开始讨论。