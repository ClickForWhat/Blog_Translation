让我们考虑更复杂一些的例子：

```asm
loop:
    add  edx, DWORD PTR [rax]
    add  rax, 4
    cmp  rax, rcx
    jne  loop
```

它使用简单的 `for` 循环，计算了一个 32 位整数数组的和。

这段代码的循环体是 `add edx, DWORD PTR [rax]`：此指令读取 `rax` 指向的地址中的数据，并把它加到 `edx`。接下来，我们将使用 `add rax, 4` 把指针向前移动 4 个字节。然后，稍微复杂一点的事情发生了。

# 跳转 - *Jumps*

汇编语言没有高级语言所具有的 if-s、for-s、函数或其他控制流结构。它所拥有的是 `goto`，或者跳转，这在低级编程的世界里差不多是这么叫的。

**跳转**会移动指令指针到操作数所指定的地址。这个地址可能是内存中的绝对地址，也可以是相对于当前地址的，甚至可以是在[运行时计算](https://en.algorithmica.org/hpc/architecture/indirect)的。直接管理这些地址相当令人头痛，因此你可以使用字符串并后跟 `:` 符号标记某条指令，然后使用这个字符串作为标签，当转换为机器码时，它被该指令的相对地址所取代。

标签可以是任何字符串，但编译器在这方面没啥创意，[通常](https://godbolt.org/z/T45x8GKa5)在为标签选择名称时，只使用源代码中的行号和函数名及其签名。

**无条件跳转** `jmp` 只能用于实现 `while (true)` 类型的循环或将程序的各个部分拼接在一起。一组**有条件跳转**用于实现实际的控制流。

我们可能会认为，这些条件在某处被计算为 `bool` 表达式，并作为操作数传递给有条件跳转：毕竟，这就是编程语言里的工作方式。但在硬件上却不是这样实现的。条件操作使用特殊的 `FLAGS` 寄存器，它会用一种指令填充该寄存器，这种指令将执行某种检查。

在我们的例子中，`cmp rax, rcx` 比较当前指针 `rax` 和数组尾地址 `rcx` 的值。这会更新 `FLAGS` 寄存器，这样它就能被 `jne loop` 指令所使用，该指令通过查找一个特定的位，告诉两个值是否相等，然后跳转回开始或中断循环继续执行下一条指令。

# 循环展开 - *Loop Unrolling*

关于上面的循环，你可能已经注意到一件事，那就是处理单个元素的开销很大。在每个循环中，只执行一条有用的指令，而其他 3 条指令只是对迭代器进行自增，并试图找出我们是否已经完成。

我们所能做的是将多次迭代所做的事情打包在一次迭代里，称之为“循环展开”，相当于在 C 中编写这样的代码：

```C
for (int i = 0; i < n; i += 4) {
    s += a[i];
    s += a[i + 1];
    s += a[i + 2];
    s += a[i + 3];
}
```

在汇编中，它看起来是这样的：

```asm
loop:
    add  edx, [rax]
    add  edx, [rax+4]
    add  edx, [rax+8]
    add  edx, [rax+12]
    add  rax, 16
    cmp  rax, rsi
    jne  loop
```

现在， 3 个循环控制指令就可以对应 4 个有用的数据处理指令（从 $\frac{1}{4}$ 到 $\frac{4}{7}$ 的效率改进），并且可以继续将开销减少到几乎为零。

在实践中，展开循环并不总是性能所必需的，因为现代处理器实际上并不逐个执行指令，而是维护一个[待处理的指令队列](https://en.algorithmica.org/hpc/pipelining)，以便两个独立无关的操作可以并发执行，而不必等待对方完成。

这也是我们的情况：展开的实际加速不会是四倍，因为增加计数器和检查是否完成的操作是独立于循环体的，因此可以与循环体并发运行。但是[要求编译器](https://en.algorithmica.org/hpc/compilation/situational)在某种程度上展开它可能仍然是有益的。

# 替代方法 - *An Alternative Approach*

你不必显式地使用 `cmp` 或类似的指令来进行条件跳转。许多其他指令会读取或修改 `FLAGS` 寄存器，虽然这只是启用异常检查时的副作用，但你可以利用它。

例如，`add` 总是设置一些标志，表示结果是零还是负，是否发生上溢或下溢，等等。利用这种机制，编译器经常产生这样的循环：

```asm
    mov  rax, -100  ; replace 100 with the array size
loop:
    add  edx, DWORD PTR [rax + 100 + rcx]
    add  rax, 4
    jnz  loop       ; checks if the result is zero
```

这段代码对于人类来说有点难以阅读，但是在重复部分中缩短了一条指令，这可能会对性能产生有意义的影响。