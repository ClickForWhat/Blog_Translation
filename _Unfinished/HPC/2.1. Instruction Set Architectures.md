作为软件工程师，我们都喜欢构建和使用抽象。

想象一下在加载 URL 时会发生多少事。你用键盘输入了一些东西；操作系统用某种方式检测你的按键输入，并发送给浏览器；浏览器解析 URL 并向操作系统要求一个网络请求；然后经过 DNS、路由、TCP、HTTP 以及 OSI 的那些层；浏览器解析 HTML；JavaScript 神奇般地做了些事情；页面的某些部分被发送到 GPU 进行渲染；图片帧被发送到监视器......在这个过程中，每一个步骤都可能涉及到几十个更具体的事情。

抽象帮助我们把复杂性降低为单一的*接口*，它仅描述一个*模块*能做什么而无需具体的实现。这有两大好处：

+ 工程师工作在较高层级时，对于底层，只需要明白接口即可。
+ 工程师在模块本身上工作的时，可以自由地优化和重构它的实现，只要它符合接口的约定。

硬件工程师同样喜爱抽象。CPU 的一种抽象被称为指令集架构（*ISA*），它定义了计算机在程序员的视角中应该如何工作。和软件上的接口类似，它让计算机工程师能够改进现有的 CPU 设计，同时也使它的用户——也就是程序员——有信心，以前能工作的东西不会在新的芯片上出现故障。

ISA 本质上定义了硬件应该如何解释机器语言。除了指令及其二进制编码外，ISA 还定义了寄存器的数量、大小和用途，内存模型，输入/输出模型。与软件接口类似，ISA 也可以扩展：事实上，它们经常更新，主要是以向后兼容的方式，添加更新的、更专门的指令，从而提高性能。

# RISC 和 CISC - *RISC vs CISC*

从历史上看，有许多种指令集架构在互相竞争。但是与[字符编码和即时消息协议](https://xkcd.com/927/)那样的东西不同，开发和维护一个完全独立的指令集架构是非常昂贵的，所以主流 CPU 设计最终会融合到两个系列中的一个：

+ ***Arm***，几乎用于所有的移动设备，以及部分像计算机的设备，比如电视，智能冰箱，微波设备，[自动驾驶系统元件](https://en.wikipedia.org/wiki/Tesla_Autopilot)等等。它们是由一家同名的英国公司以及包括苹果和三星在内的许多电子制造商设计的。
+ ***x86***[^1]，几乎用于所有的服务器和台式电脑（苹果的 M1、AWS 的 Graviton 和[目前世界上最快的超级计算机](https://en.wikipedia.org/wiki/Fugaku_(supercomputer))等是少数几个例外，它们是基于 ARM 的），由英特尔和 AMD 两大垄断公司设计。

这两者的主要区别是架构的复杂程度。请注意，这更多是设计理念的不同，而不是某种严格定义的属性：

+ 基于 Arm 的微处理器称为*精简指令集计算机*（*RISC*），它们通过保持较小的指令集和高度的优化来提高性能，不过这样一来一些不太常见的操作需要使用多个指令来实现。
+ 基于 x86 的微处理器称为*复杂指令集计算机*（*CISC*），它们通过添加许多专门的指令来提高性能，不过其中一些指令在实际程序中很少使用。

RISC 设计的主要优势是它可以产生更小更简单的芯片，从而降低制造成本和功耗。Arm 主导了使用电池供电的通用设备，而将复杂的神经网络和复杂的计算留给服务器级、高度专业化的 x86，这一点也不奇怪。


[^1]: 现代 x86 的 64 位版本更广为人知的名字是”AMD 64“、”Intel 64“，或更中立的”x86-64“、”x64“。类似的 Arm 的 64 位被称为”AArch64“或”ARM64“。在本书中，我们将只简单地用“x86”和“Arm”指代 64 位版本。