CPU 被*机器语言*所操控，所谓机器语言就是一串二进制编码的指令，用来指定

+ 指令的号码（称为*操作码*）
+ 它的*操作数*是什么（如果有的话）
+ *结果*存在哪里（如果会产生的话）

一种更加人性化的机器语言，称为汇编语言，使用助记符号来指代机器代码指令，使用符号名来指代寄存器和其他存储位置。

让我们直接切入主题，以下是用 Arm 汇编将两个数相加（`*c = *a + *b`）的例子：

```asm
; *a = x0, *b = x1, *c = x2
ldr w0, [x0]    ; 从 x0 所指向的位置加载 4 个字节到 w0
ldr w1, [x1]    ; 从 x1 所指向的位置加载 4 个字节到 w1
add w0, w0, w1  ; 将 w0 和 w1 相加，把结果存在 w0
str w0, [x2]    ; 将 w0 的内容写入 x2 所指向的位置
```

以下是相同的操作，但是 x86：

```asm
; *a = rsi, *b = rdi, *c = rdx 
mov eax, DWORD PTR [rsi]  ; 从 rsi 所指向的位置加载 4 个字节到 eax
add eax, DWORD PTR [rdi]  ; 将 rdi 的内容加到 eax
mov DWORD PTR [rdx], eax  ; 将 eax 的内容写入 rdx 所指向的位置
```

汇编语言非常简单，因为与高级编程语言相比，它没有很多语法结构。从上面的例子中你可以观察到：

+ 一个程序就是一个指令序列，每条指令开头写指令名，然后是操作数。
+ 形如 `[reg]` 的语法，表示”解引用“一个存在寄存器里的指针。在 x86 你还需要添加前缀表示大小信息（`DWORD` 表示 32 位）。
+ `;` 符号用于行注释，类似 `//` 或 `#` 。

汇编是相当小巧的语言——因为它必须如此。它尽可能地反映机器语言，直到机器代码和汇编之间几乎有 1:1 的对应关系。事实上，你可以将任何已经编译的程序转回汇编，使用一种称为*反汇编*[^1]的技术，不过所有非必要的东西（如注释等）将不会被保留。

请注意到以上两个代码片段不仅仅是语法形式上有所不同。它们都是经过编译器优化后产生的代码，但是 Arm 用了 4 条指令，x86 用了 3 条。`add eax, [rdi]` 指令被称为*熔合指令*，它把加法和存储合并为一条——这是 [CISC](https://en.algorithmica.org/hpc/architecture/isa#risc-vs-cisc) 方法可以提供的好处之一。

除了这一条，两个架构间的不同还有很多，因此从这里开始，本书将只展示 x86 上的例子，这可能是大多数读者将优化的对象，尽管许多引入的概念将与体系结构无关。

# 指令和寄存器 - *Instructions and Registers*

出于历史原因，大多数汇编的指令助记符都十分简单扼要。当过去的人们需要手写汇编并重复书写常见指令时，多写一个字符就意味着离发疯更近一步。

比如，`mov` 的意思是”存储/读取一个字（*word*）“，`inc` 的意思是”自增 1“，`mul` 的意思是”乘法“，`idiv` 的意思是”整数除法“。你可以用指令的名字在任意一个 [**x86 References**](https://www.felixcloutier.com/x86/) 中查找它的描述，但是大多数指令的作用都是你所认为的那样。

大部分指令都将它们的结果存放在第一个操作数中，这其中可能涉及计算，就像上面我们看到的 `add eax, [rdi]`。操作数可以是寄存器，也可以是常量或内存位置。

**寄存器**有 `rax`，`rbx`，`rcx`，`rdx`，`rdi`，`rsi`，`rbp`，`rsp`，以及 `r8` - `r15` 总共 16 个。纯字母的寄存器命名出于历史原因：`rax` 是累加器（*accumulator*），`rcx` 是计数器（*counter*），`rdx` 是数据（*data*）等等，但是，它们不必只用于此。

也存在 32 位、16 位和 8 位寄存器，它们具有相似的名称（`rax` → `eax` → `ax` → `al`）。但它们并非一个个单独的寄存器，而是*别名*：`rax` 的低 32 位就是 `eax`，低 16 位就是`ax`，以此类推。这样做是为了在保持兼容性的同时节省空间，这也是为什么编译型编程语言中的基本类型强制转换通常没有额外开销的原因。

这些是通用寄存器，除了一些[例外](https://en.algorithmica.org/hpc/architecture/functions)，你可以在大多数指令中随意使用它们。还有一组单独的寄存器用于[浮点运算](https://en.algorithmica.org/hpc/arithmetic/float)，一堆非常宽的寄存器用于[向量扩展](https://en.algorithmica.org/hpc/simd)，还有一些特殊的寄存器用于[控制流](https://en.algorithmica.org/hpc/architecture/loops)，但我们会讲到的。

**常量**可以是正整数或浮点数，比如 `42`、`0x2a`、`6.02e23`。它们通常被称为*立即数*，因为它们被嵌入到机器代码中。因为它可能会大大增加指令编码的复杂性，所以有些指令不支持立即数，或者只允许其中的一个固定子集。在某些情况下，你必须将常量值加载到寄存器中，然后使用它而不是直接用。

除了数值之外，还有字符串常量，如 `hello` 或 `world\n`，以及它们自己的一小部分操作，但这是汇编语言中有点晦涩的部分，我们在这里不打算进行探讨。

# 移动数据 - *Moving Data*

一些指令可能有相同的助记符，但它们的操作数的类型不同，这种情况下，它们被认为是不同的指令，因为它们可能执行略有不同的操作并花费不同的时间来执行。`mov` 指令就是一个生动的例子，因为它有大约 20 种不同的形式，都与移动数据有关：要么在存储器和寄存器之间，要么只是在两个寄存器之间。尽管有这个名字，但它并没有将值*移动*到寄存器中，而是*复制*它，保留原始值。

当用于在两个寄存器之间复制数据时，`mov` 指令在内部执行寄存器重命名，通知 CPU 寄存器 X 引用的值实际上存储在寄存器 Y 中——除了可能读取和解码指令本身外，这不会造成任何额外的延迟。出于同样的原因，交换两个寄存器的 `xchg` 指令也不需要任何开销。

正如我们在上面的加法中看到的，你不必进行任何内存读/写操作时都使用 `mov`：一些算术指令支持将内存位置直接作为操作数。

# 寻址模式 - *Addressing Modes*

内存寻址是通过 `[]` 操作符完成的，但它可以做的不仅仅是将存储在寄存器中的值重新解释为内存位置。地址操作数最多接受下面展示的 4 个参数（小写单词）：

```asm
SIZE PTR [base + index * scale + displacement]
```

其中，`displacement` 是整数常量，`scale` 是 2、4 或 8。这实际上就是通过 `base + index * scale + displacement` 这个式子来计算指针的值，然后解引用它。

使用较复杂的寻址最多比直接解引用指针[慢一个周期](https://en.algorithmica.org/hpc/cpu-cache/pointers)，当你有一个结构体数组并希望加载其第 i 个元素的特定字段时，它可能很有用。

寻址操作符需要一个大小说明符为前缀，说明需要多少位数据：

- `BYTE` 表示 8 位
- `WORD` 表示 16 位
- `DWORD` 表示 32 位
- `QWORD` 表示 64 位

还有比较少见的 `TBYTE`，表示 [80 位](https://en.algorithmica.org/hpc/arithmetic/float)，`XMMWORD`、`YMMWORD` 和 `ZMMWORD` 分别表示 [128、256 和 512 位](https://en.algorithmica.org/hpc/simd)。所有这些类型都不必写成大写，但这是大多数编译器发出它们的方式。

地址计算本身通常很有用：`lea`（*"load effective address"*）指令计算操作数的内存地址，并在一个周期内将其存储在寄存器中，而不做任何实际的内存操作。虽然它的预期用途是实际计算内存地址，但它也经常用作算术上技巧，不然就要多写 1 次乘法和 2 次加法——例如，你可以用它乘以 3、5 和 9。

它也常用作 `add` 的替代品，因为如果你需要将结果移动到其他地方，它不需要额外写 `mov` 指令：`add` 仅在使用双寄存器，类似 `a += b` 的模式下工作，而 `lea` 则可以让你执行 `a = b + c`（甚至是 `a = b + c + d`，如果其中一个是常数的话）。

# 替代语法 - *Alternative Syntax*

实际上有多种汇编程序（从汇编中产生机器码的程序）使用不同的汇编语言，但是现在只有两种 x86 语法被广泛使用。它们通常以使用它们的两家公司命名，并在那个时代对编程产生了主导影响：

+ *AT&T* 语法，默认情况下由 Linux 工具使用。
+ *Intel* 语法，默认情况下由英特尔使用。

这些语法有时也分别被称为 *GAS* 和 *NASM*，这是使用它们的两个主要汇编程序（*GNU Assembler* 和 *Netwide Assembler*）的名称。

我们在本章中使用了英特尔语法，并将在本书的其余部分继续使用它。为了进行比较，下面是 AT&T 语法中相同的 `*c = *a + *b` 示例：

```asm
movl (%rsi), %eax
addl (%rdi), %eax
movl %eax, (%rdx)
```

关键的区别可以总结如下：

1. 最后一个操作数用于指定目的地。
2. 寄存器和常数需要分别使用 `%` 和 `$` 作为前缀（如 `addl $1, %rdx`，即自增 `%rdx`）。
3. 内存寻址形式如：`displacement(%base, %index, scale)`。
4. `;` 和 `#` 都可作为行注释，`/* */` 可以作为块注释。

以及，最重要的，在 AT&T 语法中，指令名需要后缀（`addq`, `movl`, `cmpq` 等）来指定要操作的操作数大小：

- `b` = byte （8 位）
- `w` = word （16 位）
- `l` = long （32 位整数或 64 位浮点）
- `q` = quad （64 位）
- `s` = single （32 位浮点）
- `t` = ten bytes （80 位浮点）

在英特尔语法中，这些信息是从操作数推断出来的（这就是为什么你还需要指定指针的大小）。

大多数生成或使用 x86 汇编的工具都可以使用这两种语法，因此你可以选择更喜欢的一种。