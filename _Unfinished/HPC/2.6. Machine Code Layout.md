计算机工程师喜欢在心里把 [CPU 的流水线](https://en.algorithmica.org/hpc/pipelining)分成两部分：前端，指令从内存中取出并解码；后端，指令被调度并最终执行。通常情况下，性能受到执行阶段的瓶颈，因此，本书中的大部分工作将用于围绕后端进行优化。

但有时，当前端没有足够快地将指令提供给后端以使其饱和时，也会发生相反的情况。发生这种情况的原因有很多，最终都与机器代码在内存中的布局有关，并以各种原因影响着性能。例如删除未使用的代码、交换分支，甚至改变函数声明的顺序，都可能导致性能变化。

# CPU 前端 - *CPU Front-End*

在机器码被转换成指令之前，CPU 需要知道程序员想要什么，它首先需要经历我们感兴趣的两个重要阶段：获取和解码。

在**获取**阶段，CPU 只是从主存储器中加载一个固定大小的字节块，其中包含一定数量指令的二进制编码。该块大小在 x86 上通常为 32 字节，在其他机器上可能有所不同。一个重要的细微差别是，这个块必须[对齐](https://en.algorithmica.org/hpc/cpu-cache/cache-lines)：块的地址必须是其大小的倍数（在我们的例子中是 32B）。

接下来是**解码**阶段：CPU 查看这个字节块，丢弃指令指针之前的所有内容，并将其余部分拆分为指令。机器指令使用可变字节数进行编码：一些简单而非常常见的指令，如 `incrax`，需要一个字节，而一些带有编码常量和行为修改前缀的模糊指令可能需要多达 15 个字节。因此，从一个 32 字节的块中可以解码出的指令数量是不固定的，但不能超过某个与机器相关的限制，这称为解码宽度。在我的 CPU （Zen 2）上，解码宽度为 4，这意味着在每个周期中，最多可以解码 4 条指令并传递到下一阶段。

这些阶段以流水线的方式工作：如果 CPU 可以告知（或预测）下一个指令块，那么提取阶段不会等待当前块中的最后一条指令被解码完毕，而是立即加载下一条指令。

# 