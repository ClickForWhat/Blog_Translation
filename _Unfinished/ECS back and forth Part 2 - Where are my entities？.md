*本文档译自 skypjack.github.io 中关于 ECS 框架设计思想的文章，作者 Skypjack*

## 概述 - *Overview*
---
*ECS back and forth* 系列的第二部分。在给出了介于 *OOP* 和基于组件的模型之间的折中解决方案，以及实体也是索引的思想之后，我想介绍另外两种技术，它们试图消除目前为止看到的一些常见问题。特别是，我们仍然需要一种方法来找出所有实体，并且是具有给定组件集的实体。

在本系列的后面部分，我可能会深入讨论其中一个模型，这个模型是我最了解的，我可以给出更多实现细节。幸运的是，所有的解决方案或多或少都有许多共同之处。因此，在尝试实现你自己的工具时，可以重用大多数技术和建议。

如果你还没有这样做，请在继续之前阅读本系列的[第一部分](https://skypjack.github.io/2019-02-14-ecs-baf-part-1/)。

## 前言 - Introduction
---
在从面向对象到基于组件的模型的过程中，我们遗漏了一个尚未解决的问题。特别是前一部分中讨论的两种实现都要求系统迭代所有实体，以了解哪些实体具有所需的组件集。我们显然没有办法避免它。

然而，正如在计算机科学中经常发生的那样，一个额外的间接层次可以解决这个问题。因为它将有助于把客户端代码与存储实体和组件的数据结构解耦，并且允许对对象进行布局以简化搜索或填补漏洞（如果有的话）。

顺便提一句，这额外的间接比想象的更强大。事实上，我们能做的远不止重新排列组件和填补漏洞。我会试着在以后的帖子中给出更多的细节，但这超出了本文的目的。因此，在接下来的几节中，我将只关注如何为组件和实体获得打包数组，并在其中留下一些漏洞。


## 原型 - Archetypes
---
最近非常流行的一种模式是原型，至少在 *Unity* 宣布实现了它的一个版本之后。它们以前也被称为 *prototypes*，但现在似乎原型是这种方法的通用术语。

基本概念相当简单，即使实现它的有效版本一点也不简单。

这种方法背后的思想总结如下：如果一个实体有一组特定的组件（这组组件称为组件集），那么就为具有相同组件集的实体创建一个池（称为原型），并将这些实体及其所有组件分配给该池。若向某实体添加或删除组件，需要重新拾取其所有内容，将此实体及其所有组件从一个池移动到另一个池，也就是从一个原型移动到另一个原型。

实现细节并不容易，但是 *GitHub* 上有一个很好的项目 `decs`，它提供了一个基于C++的原型的实验版本。这个设计的另一个实现是 `reflecs`，尽管这是C项目而不是C++。我不是C语言接口的粉丝（毕竟我写 `uvw` 就是为了避免直接使用 `libuv`）。然而，这个项目特别有趣，因为作者试图超越通常由基于组件的模型提供的标准特性，并添加了诸如使实体成为其他实体的子实体的能力，就好像它们是组件一样。我不能说像这样的功能在日常使用中是否有用，我个人从来没有觉得有必要，但它们确实很有趣，并且这让 `reflecs` 比其他项目更有趣。

那么，原型如何解决找到所有具有特定组件的实体的问题呢？

基于原型的解决方案不再需要迭代所有实体并查看它们是否具有所需的组件。相反，这一次我们迭代所有原型（可能比实体少得多），然后我们从原型中返回所需的实体，这些实体同一堆组件在一起，这一堆组件一定包含所需的组件（但不一定只包含所需的组件）。很可能会有多个原型需要访问，但是如果一旦原型与查询匹配，则一定可以保证原型中的所有实体至少具有感兴趣的组件，因此也不必测试这些实体。这将带来巨大的速度提升。

另一个好处是原型既包含实体又包含组件，后者很可能被组织在和实体顺序一致的打包数组中。因此，访问一个原型并返回它所包含的结果即是对数组的有序访问。

最初，这种方法的其中一个优点不太明显，那就是它特别适合多线程。一般来说，基于组件的模型通常也被设计为适于多线程的。然而，如果条件允许的话，原型可以用更简单的方式做到这一点。

如果你同意包含一些组件的实体可能会分散在不同的原型中，那么你可以想象一下把原型仔细分开的情形。如果将对象放在相同大小的不同原型块中，则可以通过直接将这些块分配给不同的线程来实现更好的负载平衡。考虑到原型可能是高度不平衡的，因此第一个解决方案可能导致次优性能，并在一定程度上破坏了使用多线程的目的。

在这种情况下，多线程的实现和机理不再恼人，它的运作方式以及如何分配负载直接取决于数据在底层的布局方式。此外，存储实例的方式可以很容易地将错误共享减少到最低限度，并提高整体性能。

不幸的是，与其他解决方案一样，原型也有自己的缺点。

直观地说，要面对的第一个问题源于它们的工作方式。每次添加或删除组件时，实体及其所有组件都会从一个原型移动到另一个原型。这在一定程度上影响组件的构造和破坏。这个问题可以通过批量添加来缓解，但是如果动态地分配和删除组件的实例，就无法真正解决这个问题。

正因为如此，当分配给实体的组件集在运行时不会发生太大变化时，这个模型工作得相当良好。这在低层级系统中是正确的，但在高层级系统中不一定是这样。减少这一问题影响的一个可能解决方案是使用该模型来管理几乎固定类型的组件（例如，物理组件的实例不太可能在分配后从其实体中删除，这使物理成为固定组件中的一个很好的候选者），同时依靠辅助数据结构来处理那些在运行时经常分配或删除的组件。

不过，原型最可能遇到的主要问题是碎片化。简而言之，一个不太明显但仍然存在的问题是，原型主要不是围绕使用模式设计的。这种技术只是试图尽可能地优化所有的东西，因为众所周知，这“所有的东西”里也有我们的使用模式。这有一个缺点，那就是你失去了获得更多目标原型的机会，并牺牲了一些东西来优化你永远不会执行的迭代。更糟糕的是，如果在运行时将大量可能的组件组合分配给不同的实体，原型的数量可能会激增，这肯定会在一定程度上影响迭代，因为添加了越来越多的跳转来查找所有实体。

最后，有些东西可能是问题，也不可能是问题。这主要取决于你的观点，但这是值得一提的。

那就是实体和组件都存储在单独的块中，没法再为给定类型获取一对 `(T*， size)` 来一次迭代或拷贝所有内容。出于同样的原因，与将所有组件组合到单个数组中的其他解决方案相比，使用自定义分配器带来的好处略低。

话虽如此，与目前所看到的解决方案相比，原型是另一种模型，可以被认为是解决问题的最佳方法之一。不要忘记，完美的解决方案并不存在，每个方案都有优点和缺点。在这种情况下，如果我们从整体上考虑，它绝对是值得的。


## 稀疏集 - Sparse sets
---
稀疏集颠倒了这个问题，并以一种与原型完全不同的方式来处理它。我还没有看到很多基于这种数据结构的组件模型实现，可能是因为它可以以许多不同的方式使用，很难找到一种指导方针。因此，初识者可能会受到打击。

在描述如何使用稀疏集来解决所有实体存在哪和如何只拥有特定组件集的实体的问题之前，让我们看看稀疏集是什么以及它们是如何工作的。

### 称之为稠密数组的东西 - They called them packed arrays

稀疏集是这样一个东西：

	[...] 一个智能的数据结构，用于存储从 0 .. u-1 的稀疏整数集。执行初始化、查找和插入的时间为O(1)，迭代时间为O(n)，其中n是集合中元素的个数。

至少根据这篇有趣的[文章](https://programmingpraxis.com/2012/03/09/sparse-sets/)，它清楚地解释了它们是如何工作的。

如果你知道该搜索什么，你也可以直接在网上找到博客文章和稀疏集/稠密数组的使用示例。例如， *BitSquid* 博客中有一篇关于它的[文章](http://bitsquid.blogspot.com/2011/09/managing-decoupling-part-4-id-lookup.html)。同样，*Molecular Matters* 试图在其“面向数据设计大冒险”系列[文章](https://blog.molecular-matters.com/2013/07/24/adventures-in-data-oriented-design-part-3c-external-references/)中给出一些关于这个主题的细节。

就我个人而言，这次我不想深入讨论这个问题。我建议在继续之前先阅读上面的文章，了解稀疏集是如何工作的。

简而言之，这种数据结构包含两个数组：前者是一个稀疏数组（也称为外部或反向数组），后者是一个稠密数组（也称为内部或直接数组），因此经常使用这个名称来指代稀疏集。要知道稀疏集是否包含一个值（例如一个实体标识符），你可以执行以下测试：

```C++
const bool match = (packed[sparse[entity]] == entity);
```

如果 `match` 为真，则稀疏集包含给定值。幸运的是，当你希望迭代稀疏集所包含的所有值时，不需要使用这种间接方法。直接从稠密数组第一个元素遍历到最后一个元素就可以了。这种双重访问模式使它们既快速又灵活。

一般来说，到目前为止我看到的所有实现都与理论版本略有不同。如果你对你的数据掌握更多信息，那就可以对稀疏集进行多种优化。因此，在大多数情况下，你可以轻松地摆脱间接，或者在一个或两个数组中存储多出来的信息。作为一个例子，*EnTT* 提出的实现与经典的实现有很大的不同，如果不知道细节并能够理解差异，几乎没有人会说它是一个稀疏集。

### 使用稀疏集的系统 - Systems own sparse sets

### 独立的稀疏集 - Independent sparse sets

### 最后的注意事项 - Final notes on sparse sets


## 原型，还是稀疏集？ - So, archetypes or sparse sets?
---
这个问题没有答案，至少在我看来是这样。以我的经验来看，这两种解决方案都可以发挥同样的作用，并且如果执行得当，它们都有各自的优点和缺点。这两种解决方案都有优点和缺点，并且每种解决方案都提供了其他解决方案无法获得的功能。因此，可能选择应该更多的是由于品味的问题，而不是个别方法的性能。

我个人认为，在这两种情况下，出现的任何性能问题都不太可能是由于在迭代上花了过多的时间。最有可能的是，瓶颈出现在其他地方。因此，在这里我不会直接建议任何一种解决方案。当然，我在两者间做出了我的选择，但我不认为这比另一个更好或更差。我认为这两种方法中的一种所提供的特性更接近我的思考和编写代码的方式，因此，我更喜欢这种解决方案。

事实上，这是一个品味问题。