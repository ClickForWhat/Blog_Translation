*本文档译自 The Machinery Engine Dev Blog 的 "The Story behind The Truth" 一文，作者 Niklas Gray*


## 概述 - *Overview*
----
我之前讲过一点关于 *The Truth* 的东西，我们在引擎中用来表示数据的系统。但我还没有详细说明为什么我们选择这种方法而不是其他方法。*Jascha Wedowski* 在推特上写信给我们，想知道更多关于这个的信息，我认为这是一个非常有趣的博客话题，所以我们开始吧。


## 什么是数据模型，为什么应该有一个数据模型？ - *What is a data model and why should you have one？*
---
让我们从头开始。大多数软件程序都需要某种表示和存储数据的方法。用一个词来形容它，我们称之为程序数据模型。有很多种可能的数据模型：

-   [*XML*](http://web.archive.org/web/20220529231022/https://en.wikipedia.org/wiki/XML) 文件和一些 [*schema*](http://web.archive.org/web/20220529231022/https://en.wikipedia.org/wiki/XML_Schema_(W3C)) 语言
-   [*JSON*](http://web.archive.org/web/20220529231022/https://www.json.org/) 文件和某些具有共识的结构
-   应用程序自己定义的二进制格式
-   具有良好定义结构的共享二进制格式，如 [*ASN.1*](http://web.archive.org/web/20220529231022/https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One)
-   [关系型数据库](http://web.archive.org/web/20220529231022/https://en.wikipedia.org/wiki/Relational_database)
-   [非关系型数据库（*nosql*）](http://web.archive.org/web/20220529231022/https://en.wikipedia.org/wiki/NoSQL)
-   带有散列标识符的、具有版本特征的，层次结构（类似于 *git* 存储库）。
-   …...

应用程序可以具有相同数据的多种表示形式。例如，程序可能在磁盘上使用 *JSON* 配置文件，但是当程序启动时，这些文件被读入内存中的数据结构。*JSON* 文件是永久性的，具有良好定义的结构，并且可以很容易地在程序之间共享。内存表示的访问速度更快，但它是临时的，缺乏高级结构，不能轻易共享。

在这篇文章中，当我谈论数据模型时，我主要谈论的是这些更持久的、结构化的模型。

大多数程序不会处理那么多数据，而且计算机速度很快，所以每次运行程序或每次打开文件时，它们都可以在结构化文件表示和高性能内存表示之间转换。但游戏不太一样。它们通常处理千兆字节的数据，并且需要运行得非常快。转换游戏的所有数据会导致启动时间非常长。因此，它们通常在单独的数据编码阶段中从结构化格式转换为内存格式。然后将内存中的表示存储在磁盘上（需要将其存储在某个地方），之后可以快速流式传输到内存中并立即使用，而无需任何昂贵的解析或转换。

为什么不一直使用内存格式？这样就可以跳过编码阶段。可以，但通常更结构化的格式（无论采用哪种格式）有一些优势。例如，编码后的数据可能是一个大的 *.pak* 文件，它不能很好地与版本控制一起工作。它可能没法很好地合并，因此当多人在项目上工作时，它就不适合了。它也可能会丢弃诸如调试字符串或压缩纹理等信息，以减少最终游戏的大小。

拥有一个结构化的数据模型是很有用的，因为它允许我们在数据模型上实现数据具有的特性，而不是在使用它的系统上。这意味着我们只需要执行一次功能，并且所有系统都将获得它，而不必在每个系统中单独执行。

例如，考虑[向后兼容性](http://web.archive.org/web/20220529231022/https://en.wikipedia.org/wiki/Backward_compatibility)。向后兼容性意味着程序的未来版本能够打开旧版本的文件，即使数据以某种方式发生了变化（例如，我们可能向对象添加了新属性）。这是一个非常重要的功能，因为如果没有它，应用程序更新将破坏所有用户的旧文件。

在没有数据模型支持的情况下，支持向后兼容性可能意味着保留所有代码以解析每个过去版本的数据。你的代码可能看起来像这样：

```C++
if (version == VERSION_1_0) {
    ...
} else if (version == VERSION_1_1) {
    ...
} ... 
```

相反，如果您的数据模型处理向后兼容性，则不必做任何事情。作为一个示例，考虑 *JSON*。只要是添加和删除属性，并为任何新属性提供合理的默认值，*JSON* 就会自动向后兼容。*JSON* 也可以很好地实现前向兼容性，即允许旧的可执行文件打开新数据。旧的可执行文件会忽略任何它们不理解的属性。如果没有某种结构化的数据模型，向前兼容性很难实现，因为您不能对未知的数据的未来版本进行 `if (version == ??)` 测试。

除了向后和向前兼容性之外，数据模型还有很多其他方面的潜在帮助：

