*本文档译自 blog.molecular-matters.com 的 "Memory System" 系列文章，作者 Stefan Reinalter*


## 概述 - *Overview*
----
在 *Memory System* 系列的前几期中，我们主要关注使用 `new` 和 `delete` 的普通内存分配在内部如何工作，以及如何构建自己的工具来提供额外的功能。我们还没有讨论的一件事是 *Memory Arena*，它负责实际分配内存，同时提供额外的功能，如边界检查，内存跟踪等。

在这一篇文章，我们将会看看不同的内存分配设计和它们的用例，然后尝试构建我们自己的 *Memory Arena*。

首先，我们构建我们自己的内存分配工具，目的不是为了创造一个通用分配器，然后取代另一个通用分配器。这是因为：

+ 现在，操作系统的大多数通用分配器，要么使用 [*Douglea's malloc*](http://g.oswego.edu/dl/html/malloc.html)（仍然是最好的分配器之一，即使它是在 10 多年前推出的），要么使用 [*ptmalloc*](http://www.malloc.de/en/)，[*tcmalloc*](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)，[*Hoard*](http://www.hoard.org/) 之类的东西。你几乎不可能打败它们，所以不要轻易尝试。
+ 游戏中的内存分配可以更快，因为我们知道我们在什么时候、什么地方以及在什么环境下分配内存。并不是每个分配器都需要是通用的，也不是每个分配器都需要是线程安全的——恰恰相反。
+ 即使你用一些适合游戏的技巧来增强通用分配器（例如，使用内存池进行小分配），它仍然不能完全解决庞大的任务/用途——我们已经看到，使用采用了几种性能提升技巧的单线程线性内存分配器而不是通用分配器，就可以提高200倍的速度。
+ 边界检查、内存跟踪和内存标记不是需要全局关注的问题，因此它们不应该被内置到通用分配器中。如果我们已经知道哪个子系统正在泄漏内存，我们就不需要跟踪每一次内存分配。

为了更好地理解我所说的内容，让我们看一看内存分配例程的一种可能的实现，它被用作通用分配器的替代品：

```C++
void* TheMemoryAllocator::Allocate(size_t bytes, ...)
{
	// enter critical section, mutex, etc.
	
#if BOUNDS_CHECKING_ENABLED
	bytes = TheBoundsChecker::AdjustSize(bytes);
#endif
	
	// do general purpose allocation
	void* memory = ...;
	
#if MEMORY_TRACKING_ENABLED
	// grabs the callstack internally, rather slow
	TheMemoryTracker::AddAllocation(memory);
#endif
	
#if MEMORY_MARKING
	TheMemoryMarker::Mark(memory);
#endif
	
	// leave critical section, mutex, etc.
	
	return memory;
}
```

以上是对内置分配器的改进，因为它增加了边界检查和内存跟踪等调试功能，而无需依赖外部应用程序，并且你当然可以使用它发布游戏。但是，它还是有一些让我不舒服的怪癖：

+ 边界检查和内存跟踪现在是全局的。可以使用预处理器宏 `MEMORY_TRACKING_ENABLED` 打开和关闭它们，但这适用于整个应用程序。这导致了启用内存跟踪、重建代码、启动应用程序——结果发现游戏现在需要10分钟才能启动（获取完整的调用堆栈相当慢），并且由于内存跟踪器造成的开销，额外的开发工具包内存也会用完。这不是一个有用的功能。
+ 只有一种内存跟踪可用——这意味着如果我们想添加额外的内存跟踪，代码很快就会变成一堆预处理器 `#if/#endif` 语句。而且我们也不想仅仅为了实现跟踪就为每个分配获取完整的调用堆栈。
+ 线程安全现在是全局的。许多分配并不需要是线程安全的，并且有不同的方法来实现线程安全（线性分配器可以很容易地实现[无锁或无等待](http://en.wikipedia.org/wiki/Non-blocking_algorithm)），而不必依赖于繁重的同步原语，如互斥锁或临界区。

在说了我们不希望发生的事情之后，让我们看看一些在游戏生命周期中发生的内存分配的真实案例：

+ 线性分配，例如所有具有应用程序生命周期的分配。它们在开始时被分配一次，并在退出游戏时被释放。它们是固定大小的，可以以线性方式分配，通常不涉及线程，因此它们可以是单线程的。但是，内存跟踪和边界检查需要是可选的，因为其中一些分配可能会在以后成为多级分配，反之亦然。
+ 在一个帧内的线性分配，例如所有的分配都由渲染队列完成。渲染队列每帧构建一次，大小固定，需要线性分配内存以增加缓存利用率，通常涉及多个线程进行多线程渲染。同样，边界检查和内存跟踪是可选的。
+ 基于堆栈的分配，例如生命周期类似于关卡（或之类的东西）的分配。关卡加载通常可以以基于堆栈的方式完成，这意味着分配以相反的顺序释放。此外，不同的关卡需要不同的内存量，因此所需的内存量是可变的。
+ 对象池，例如用于粒子。它们的大小是固定的，拥有一定数量的实例，可以是单线程的，也可以不是，并且提供 *O(1)* 的分配和释放。
+ 基于块的分配，例如将关卡流送的数据切成大小相等的块。最大内存量是固定的，分配通常需要线程安全，分配器还可以提供动态碎片整理。
+ 单帧分配，用于一帧期间的所有临时分配。通常，为了完成一些工作，你只需要为一个帧分配内存，然后帧结束时立即释放分配的内存。这与上面提到的来自渲染队列的线性分配相当，但是为了能够提供更好的缓存利用率，你通常希望使用不同的分配器。其中一些不必是线程安全的，而另一些则需要。
+ 两帧分配，例如用于存储需要在下一帧使用的临时结果，例如由 *SPU* 完成的光线投射，在下一帧中使用（如果一帧的延迟是可以容忍的话）。
+ 将文件解压缩到辅助缓冲区所需的通用分配，例如来自第三方库/中间件的分配，或来自文件系统的临时可变大小分配。
+ 短期临时分配，例如用于执行算法或类似算法时所需的辅助分配。它们可以从栈中分配，这得益于增加的数据局部性，而不会分割任何堆分配器。

上面的列表并不是一个详尽的列表，但是我们已经确定了许多不同的分配策略，以及所有可选的附加功能，如边界检查、内存跟踪、内存标记和线程安全。另一个例子是 *Naughty Dog* 的 *Jason Gregory* 所写的[《*Game Engine Architecture*》](http://www.amazon.com/Game-Engine-Architecture-Jason-Gregory/dp/1568814135/ref=sr_1_2?ie=UTF8&qid=1310723663&sr=8-2)。

在讨论如何将这些需求合并到我们的 *Memory Arena* 系统之前，让我们快速总结一下需求。


## 边界检查 - *Bounds check*
---
[边界检查](http://en.wikipedia.org/wiki/Bounds_checking)是一个有用的工具，通过在每个分配的开始和结束添加一个 4 字节的 *Magic Number* 来查找内存漏洞。在释放一个分配时，我们可以检查内存是否仍然包含 *Magic Number*，如果没有，它一定已经被覆盖，这可能导致内存损坏和难以跟踪的错误。

边界检查有三种方式：

1. 不做边界检查（发行版本）。
2. 简单的边界检查，如上所述。用于检查是否发生内存重叠。
3. 扩展边界检查，在每次分配/解除分配时检查所有分配的 *Magic Number*。有助于发现内存何时会重叠。


## 内存跟踪 - *Memory tracking*
---
内存跟踪用于通过跟踪应用程序生命周期中的每个分配来查找内存泄漏。内存跟踪有几种方式：

1. 不做内存跟踪（发行版本）。
2. 简单的内存跟踪。可以通过计算分配的数量来检测泄漏的存在，例如通过 `++numAllocations` 和 `--numAllocations`。不会检测泄漏来自何处（非常快，在所有构建中都可用）。
3. 扩展内存跟踪。额外存储进行分配的文件名和行号（仍然很快，需要额外的内存）。
4. 完整的内存跟踪。为每个分配存储一个完整的调用堆栈，这对于难以跟踪的泄漏（缓慢，需要更多内存）非常有用。


## 内存标记 - *Memory marking*
---
内存标记通过用特定的[位模式/*Magic Number*](http://en.wikipedia.org/wiki/Magic_number_%28programming%29#Magic_debug_values)标记内存来帮助查找悬空指针。*Visual Studio* 调试堆实现已经做到了这一点，用 *0xCDCDCDCD* 标记新分配的堆内存，用 *0xDDDDDDDD* 标记释放的内存。位模式需要被谨慎选择，这样访问指针将触发段错误、未对齐读取（在某些CPU上）或其他错误。

内存标记可以打开或关闭。


## 线程安全 - *Thread-Safety*
---
分配例程的线程安全性有几种形式：

1. 单线程
2. 多线程
3. 无锁或无等待


## 内存位置 - *Memory location*
---
我们希望能够决定分配是在堆上还是在栈上进行。是的，在执行后一种操作时必须小心，但它可以极大地提高性能并减少堆碎片。


## 分配策略 - *Allocation strategies*
---
如上所述，游戏中有几种分配策略：

1. 线性分配
2. 基于堆栈的分配
3. 基于块的分配
4. 对象池分配
5. 增长的对象池分配
6. 通用目的的分配


## 总结 - *Summary*
---
吔！可以看到，内存系统需要满足很多要求。到目前为止，我们已经确定了至少 6 种不同的分配策略，2 个不同的分配来源（堆/栈），3 种线程安全，以及几种纯粹可选的边界检查、内存跟踪和内存标记。尽管如此，我们仍然希望能够任意地将上述所有功能组合成简单、易于使用的 *Memory Arena*。

下节课，我们将学习如何做到这一点。同时，试着想想可能的解决方案。