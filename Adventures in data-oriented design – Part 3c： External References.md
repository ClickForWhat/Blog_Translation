*本文档译自 blog.molecular-matters.com 的 "Adventures in data-oriented design" 系列文章，作者 Stefan Reinalter*


## 概述 - *Overview*
----
在本系列的上一期中，我们讨论了 *Molecule* 引擎中的句柄/内部引用，并讨论了它们相对于原始指针和普通索引的优势。

简而言之，句柄能够检测重复删除，阻止访问已销毁的数据，并且无法通过它意外释放，你可以阅读之前的博客文章了解所有细节。

这一次，我们将引入 *ID* ，或者叫外部引用，这也允许我们在内存中移动单个数据项并且是在幕后悄悄进行。但我们为什么要这么做呢？

答案很简单：*Molecule* 的世界管理使用 [*Entity-Component-System*](http://en.wikipedia.org/wiki/Entity_component_system)，其中每个 *Entity* 都由其所有的 *Component* 定义。组件是小的、正交的（译注：即不相关的）数据片段，各个 *System* 负责处理各自对应的组件。所有组件都是简单的 *POD*（*Plain Old Data*），不包含任何逻辑或代码；所有逻辑代码都驻留在独立的 *System* 中。

例如，*SkinnedMeshComponent* 存储了各种数据的句柄，包括蒙皮数据的双缓冲顶点缓冲区，以及着色器和材质。它不包含任何代码，可以随意复制。

那么为什么我们需要在内存中移动单个数据项呢？

+ 创建和销毁组件应该是 *O(1)* 的操作。否则，在玩了几个小时游戏后，或者在创建大量组件时，性能可能会严重恶化。
+ 遍历并更新所有的组件应该做到尽可能少的 *cache miss*。因此，所有项都应该在内存中紧密且连续地排列，就像数组一样。

显然，这两个要求是相互矛盾的。我们可以通过使用 [*free-list*](https://molecularmusings.wordpress.com/2012/09/17/memory-allocation-strategies-a-pool-allocator/) 来 *O(1)* 地创建和销毁组件，这解决了我们的第一个问题。但是这样一来，我们不能以缓存友好的方式遍历所有组件。

另一方面，使用简单的数组可以满足我们的第二个需求，但是如果不使用任何辅助数据结构，创建和销毁组件就变成了 *O(N)* 的操作。


## 一个自定义数据结构 - *A custom data structure*
----
与许多编程问题一样，可以通过一层额外的[间接](http://en.wikipedia.org/wiki/Indirection#cite_note-1)来解决问题。

实际上，我们不单独使用 *free-list* 或数组，而是两者一起使用：一个由 *free-list* 管理的稀疏数组，以及另一个容纳一个个组件的密集数组。

稀疏（外部）数组存储密集（内部）数组的索引，以及每个数据项的 *generation*。这是我们上次介绍过的一个单调递增的计数器。密集数组将数据项连续地存储在内存中，就像常规数组一样。

这个数组中的数据不是通过句柄引用的，而是通过所谓的 *ID* 引用的。*ID* 存储稀疏数组的索引，以及此时的 *generation*。

让我们详细看看在这种数据结构上进行操作时的性能表现：

+ 创建一个组件要在密集数组的末尾添加一个新组件（*O(1)*），然后使用就地 *free-list* 在稀疏数组中分配一个新 *slot*（*O(1)*）。*slot* 将保存内部数组的索引，用户保留一个 *ID*，该 *ID* 是外部数组的智能索引（*O(1)*）。
+ 销毁组件意味着 *ID* 保存的 *slot* 需要重新插回 *free-list*（*O(1)*），并且需要从内部数组中删除该组件。这可以通过将要移除的组件与数组中的最后一个交换来完成 *O(1)* ，并将相应的索引改变从外部数组适当地更新到内部数组。
+ 由于多了一层间接，访问组件会导致额外的 *cache miss*：我们首先需要访问稀疏数组以获取索引，并使用该索引从内部数组检索组件。
+ 遍历所有组件仅仅在密集数组上进行简单的 *for* 循环即可，从产生尽可能少的缓存 *cache miss*。

可以看到，创建和销毁是 *O(1)*，遍历所有组件就像遍历一个普通数组。唯一的缺点是对组件的每一次外部随机访问都有额外的 *cache miss*。但是你可以认为来自各个组件系统外部的访问应该远远少于每个帧的内部数据访问，因此这样的数据结构在几乎所有情况下都应该是一种胜利。

此外，如果你需要的话，可以在一帧中完成一次某些组件的查找，然后将指向底层组件的指针缓存下来。我不建议这样做，但如果你真的需要在每一帧中多次访问数千个个单独的组件，那么这样做是有益的。

*Bitsquid Engine* 使用类似的数据结构，称为 *[packed array](http://bitsquid.blogspot.co.at/2011/09/managing-decoupling-part-4-id-lookup.html "Bitsquid Engine packed Array")*，但我的实现与 *Niklas* 的不同。


## 结语 - *Conclusion*
----
在 *Molecule* 中，我使用 *ID* 来引用各种组件。用户只能看到 *ID*，其他什么都看不到。因此，*ID* 与句柄都有其好处。当与 *Entity-Component-System* 结合使用时，还有一些额外的好处：你的组件不需要基类，因为 *Entity* 可以简单地存储 *ID* 数组或整数数组。这使得 *Component* 和 *Entity* 之间的耦合更少。

这是关于所有权和数据引用的迷你系列最后一部分内容，希望你喜欢！