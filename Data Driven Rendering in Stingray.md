*本文档译自 bitsquid.blogspot.com 的 "Data Driven Rendering in Stingray" 一文，作者 Ben Mowery*


## 概述 - *Overview*
----
我们都熟悉数据驱动架构给游戏带来的好处：代码与数据解耦，支持实时链接和快速迭代。在编辑器中放置新对象或修改角色的速度会直接对正在运行的游戏实例产生影响。当你调整脚本，游戏玩法和其他内容时，这将加速你的开发过程。

那么图形编程呢？事实证明，相同的架构和其中的好处同样适用于 *Stingray* 的渲染器。

只需修改配置文件（尽管可能有些复杂），我们就可以实现新的着色器程序、后处理效果，甚至完全不同的级联阴影贴图实现方式。所有这些都是实时的，在一个实时的游戏实例上。这对图形程序员来说是一个巨大的胜利：持续尝试新的想法，通过实时反馈来微调着色器。再也没有那个漫长的编辑/编译/运行/调试周期了。这适用于整个渲染管道：从对象空间到世界空间的所有转换，再到阴影投射，最后整个渲染过程都以配置文件数据的形式公开，而不是像传统架构那样以 C++ 代码的形式公开。

不久前我做了一个关于这个话题的演讲，现在已经在我们的 *YouTube* 频道上发布了：

https://www.youtube.com/channel/UC0fIe6XV1PjilADTei9JMOA

顺便说一下，那里有很多其他很棒的 *Stingray* 内容，所以你可以看看！渲染器演示可以在 *Stingray* 渲染配置教程中找到，详细信息和 *PPT* 都在这里。该代码添加一个琐碎的灰度后处理效果：

**settings.ini**;

*render_config* 变量指向 *renderer.config* 文件。*Settings.ini* 还提供了一个部分来覆盖下一个文件中的默认设置。*renderer.render_config*

**core/stingray_renderer/renderer.render_config:**

这指向我们的着色器库，包含实际着色器程序的文本文件。称为全局资源的部分分配图形缓冲区，例如用于级联阴影映射的划痕缓冲区和用于与主帧缓冲区一起延迟渲染的 *G-Buffer*。大多数实际呈现都是在资源生成器部分调用的。同样，*YouTube* 视频中的更多细节虽然数量惊人，但可以通过浏览各种配置文件和播放设置来学习。这是很容易做到的，因为它都是数据驱动的。

**core/stingray_renderer/shader_libraries/development.shader_source:**

几个着色器库之一。虽然着色器代码可以在此处以文本形式输入，但 *Stingray* 还提供了一个基于图形节点的着色器编辑器。我们支持 *Max* 或 *Maya* 中的 *ShaderFX* 材质。以图形方式实现着色器通常更容易（也更便携）。

但是，无论选择何种方法来实现着色器，关键是 *Stingray* 的整个渲染管道都可以通过配置文件完全访问。通过我们的数据驱动架构，进行复杂的渲染更改，虽然仍然不是小事，但比使用特定于平台的 C++ 代码要快得多，也更容易（而且可移植！）。