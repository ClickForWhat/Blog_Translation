*本文档译自 blog.molecular-matters.com 的 "Adventures in data-oriented design" 系列文章，作者 Stefan Reinalter*


## 概述 - *Overview*
----
正如在上一篇博文中承诺的那样，今天我们将看看 *Molecule* 如何处理子系统数据的内部引用。

首先，简要回顾一下我们不希望使用指针引用数据的原因：

+ 对于原始指针，所有权有时是不明确的。如果有人递给我一个指针，我需要负责删除该实例吗？谁拥有它？我能持有多久？这很快就会导致双重删除或者悬空指针。如果你运气不好，这两种Bug都很难解决。
+ 通过使用 `shared_ptr<>` 或一些引用计数机制，可以在一定程度上缓解上述问题，但现在我们增加了不必要的额外开销。并且所有权仍然不清楚，什么时候引用计数/智能指针背后的数据会被释放？还有谁持有它？
+ 如何通过指针复制或拷贝内容，例如在跨网络传输数据的时候？你总是必须有某种序列化机制，因为你不能只通过网络发送个指针，它们包含的地址在不同的地址空间中没有意义。
+ 指针不支持重新移动位置。最终，拥有数据的系统还要负责管理数据的内存。因此，系统可能希望能够在内存中移动内容，例如用于运行时的内存碎片整理。为此，你需要通知每个可能包含指向系统内部数据的指针，这非常繁琐且容易出错。

因此，现在让我们仔细看看如何存储内部引用，而不会遇到上述问题。


## 句柄 - *Handles*
----
在 *Molecule* 引擎中，句柄用于引用子系统内部的数据。也就是说，它们直接引用某个系统所拥有的数据，而不是通过某种间接的方式。这也是它们被称为内部引用的原因。

什么是句柄？基本上，它们是数据的**索引/下标**。但有一点不同，你可以认为句柄更加智能一些。但是在详细讨论句柄之前，我们来看看普通索引已经解决了哪些问题：

+ 不会意外地对索引调用 `delete` 或 `free()`。此外，如果一个系统只将索引作为输入和输出参数来处理，那么应该清楚系统是拥有数据的。
+ 索引可以很容易地复制和拷贝。它们还支持开箱即用的数据重定位：如果我们想访问下标为3处的*data*，那么数据本身位于何处并不重要，只要它依然保持相同的顺序排列即可。它可以位于地址*0xA000* 或 *0xB000* 或其他位置，只需要使用 `data[3]` 就能提供我们想要的数据。

当然，这种普通索引是不支持一些东西的：

+ 我们无法检测到对过期或已删除数据的访问。例如我们会尝试访问下标为3处的数据，但可能在上次访问之后，这些数据就被释放了。
+ 整个数据块可以在内存中移动，但是不能改变其中单个数据项的顺序，否则这会打乱我们的索引。

句柄能帮助我们解决第一个问题，但它也不支持重定位单个数据项。这就是 *ID* （也可以叫外部引用）的作用，但这将是下一篇文章的主题。

其思想非常简单：句柄既保存索引，还保存此时索引的 *generation*。*generation* 是这样的一个东西：一个单调递增的计数器。每次删除一个数据项时，此数据项的计数器将递增。是的，*generation* 既会存储在句柄中，每个数据项自己也会有一个。当我们想要使用句柄访问数据时，索引的 *generation* 和数据项的 *generation* 必须匹配。


## 例子 - *An example*
----
回到上一篇文章的例子，让我们假设渲染后端为4k顶点缓冲区分配了空间。新的顶点缓冲区在内部使用池分配器或 *free-list* 进行分配，用户只会处理 *VertexBufferHandle*。

最初，我们的顶点缓冲区池子是空的，所有 *generation* 都被设置为零。

	4096 vertex buffers:
	+----+----+----+----+----+----+
	| VB | VB | VB | .. | VB | VB |
	+----+----+----+----+----+----+
	4096 generations:
	+----+----+----+----+----+----+
	| 0  | 0  | 0  | .. | 0  | 0  |
	+----+----+----+----+----+----+

第一次分配顶点缓冲区时，句柄将存储一个值为0的索引和一个值为0的 *generation*。之后分配的顶点缓冲句柄将存储一个值不为0的索引，还有一个值仍为0的 *generation*。

假设我们现在销毁了我们分配的第一个顶点缓冲区。对应其位置的 *generation* 将递增，就会变成下面这样：

```
+----+----+----+----+----+----+
| VB | VB | VB | .. | VB | VB |
+----+----+----+----+----+----+
+----+----+----+----+----+----+
| 1  | 0  | 0  | .. | 0  | 0  |
+----+----+----+----+----+----+
```

再之后，如果我们想要使用句柄访问顶点缓冲区，我们检查句柄的 *generation*（值为0） 与顶点缓冲区中对应的 *generation*（值为1），然后会发现它们不匹配，这意味着我们试图访问已经删除的数据。

在代码中，这种情况看起来如下所示：

```c++
VertexBufferHandle handle = backend::CreateVertexBuffer(...);
 
// some more vertex buffers created in the meantime
 
// at a later point in time, we destroy the vertex buffer...
backend::DestroyVertexBuffer(handle);
// ...but somebody, somewhere, still holds the same handle
 
backend::AccessVertexBuffer(handle);
```


## 句柄的代码实现 - *Handle implementations*
----
我们还没有讨论的一件事是如何实现句柄。大多数时候，最简单的解决方案总是最好的，所以在这种情况下，一个简单的结构体就足够了：

```C++
struct Handle
{
	uint32_t index;
	uint32_t generation;
};
```

在实践中，通常不会同时把索引和 *generation* 设为两个 32 位整型，而是使用位字段。在以顶点缓冲句柄为例子的情况下，我们需要12位来存储范围\[0, 4095\]中的索引，如果我们希望我们的句柄一共占 32 位，则还能为 *generation* 留下 20 位。因此，我们的句柄看起来更像下面这样：

```C++
struct Handle
{
	uint32_t index : 12;
	uint32_t generation : 20;
};
```

这意味着在我们的池中的同一个 *slot* 中删除了 1048576 个顶点缓冲区后，*generation* 就会溢出。因此从理论上讲，我们还是有几率通过一个旧句柄错误地访问顶点缓冲区——也就是该句柄是在某一个 *slot* 上分配缓冲区时创建的， 然后经过了 1048576 次顶点缓冲区创建/删除之后，又访问了它。不过在实践中，这种情况几乎不会发生，除非我们将一个句柄存储很长时间，还疯狂地创建/删除缓冲区，并且在此期间完全不使用该句柄访问缓冲区。当然，出现这种情况的几率取决于你愿意多花多少比特，所以要记住这一点。

最后，我在上一篇博客文章中提到的另一件好事是，它们使用的内存少于指针。大多数句柄都可以将其索引和 *generation* 存储在一个 32 位整数中，这意味着与 64 位指针相比，它们需要一半的内存量。此外，我们实际上只需要将 *generation* 存储在句柄中，以检测对过期数据的访问。在 *Release* 版本中我们不需要这样，如果索引只需要在\[0, 65535\]范围内，句柄可以在这些版本中只占 16 位。


## 泛型实现 - *A generic implementation*
----
在 *Molecule* 中，我实现了一个通用的句柄，它根据特定的构建规则定义了底层数据类型，并且还使用 `static_assert` 断言比特是否适合该类型。基本结构如下：

```C++
template <size_t N1, size_t N2>
struct GenericHandle
{
	// uint16_t or uint32_t, depending on build type, realized using preprocessor-#ifs
	uint32_t index : N1;
	uint32_t generation : N2;
};
```

所有的句柄类型都变成了简单的类型定义：

```C++
typedef GenericHandle<12, 20> VertexBufferHandle;
```

今天的文章到此结束！在本系列的下一部分中，我们将讨论外部引用如何允许在内存中移动单个数据项，而不需要用户代码操心。