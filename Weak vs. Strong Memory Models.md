*本文档译自 preshing.com 中关于 "Lock-Free Programming" 主题的文章，作者 Jeff Preshing*


## 概述 - *Overview*
----
内存重排有多种类型，但并非所有类型的重排序都同样频繁地发生。这完全取决于你的目标处理器以及用于开发的工具链。

内存模型将告诉你，对于给定的处理器或工具链，相对于给定的源代码，在运行时可能会进行哪一种类型的内存重排序。请记住，只有在使用[无锁编程技术](http://preshing.com/20120612/an-introduction-to-lock-free-programming)时才能观察到内存重排序的效果。

在对内存模型进行了一段时间的研究（主要是通过阅读各种在线资源并通过实验进行验证）之后，我将它们分为以下四类。下面的图中，每个内存模型都包含了处于它左边的内存模型约束，以及一些额外的约束。我在弱内存模型和强内存模型之间画了一条清晰的界限，以捕捉大多数人使用这些术语的方式。请继续阅读我这样做的理由。

![[weak-strong-table.png]]

上图中的每个物理设备都代表一个硬件内存模型。硬件内存模型告诉你在运行时相对于汇编（或机器）代码可能会进行的内存排序。

当涉及到内存重新排序时，每种处理器系列都有不同的习惯，这些习惯只能在多核或多处理器配置中观察到。考虑到多核现在是主流，对它们有一些了解是值得的。

还有软件内存模型。从技术上讲，一旦在 *C11*、*C++* 11 或 *Java* 中编写（并调试）了可移植的无锁代码，就只需要考虑软件内存模型了。尽管如此，对硬件内存模型的一般理解可能会派上用场。它可以帮助你在调试时解释意外的行为，也许同样重要的是，你可以理解错误的代码如何在特定的处理器和工具链上侥幸地正常运行。


## 弱内存模型 - *Weak Memory Models*
---
在最弱的内存模型中，有可能经历我在上一篇文章中用“源代码控制类比”所描述的四种内存重新排序。任何加载或存储操作都可以被任何其他加载或存储操作一起重新排序，只要这样做不会修改它在单线程下的行为。实际上，重排序可能是由于编译器对指令重新排序，也可能是处理器本身对内存操作重新排序。

当一个处理器有一个弱硬件内存模型时，我们倾向于说它是弱序（*weakly-ordered*）的。我们也可以说它有一个宽松（*relaxed*）的内存模型。久负盛名的 *DEC Alpha* 是大家最喜欢的弱序处理器的例子。没有比这更“弱”的主流处理器了。

*C11* 和 *C++* 11 编程语言暴露了一个弱软件内存模型，该模型在许多方面受到 *Alpha* 的影响。在这些语言中使用低级原子操作时，你是否真正针对 *x86/64* 等强硬件内存模型的处理器并不重要。正如我之前所演示的，即使只是为了防止编译器重新排序，你仍然必须指定正确的内存排序约束。

### 弱数据依赖顺序 - *Weak With Data Dependency Ordering*

虽然随着时间的推移，*Alpha* 已经变得不那么重要了，但我们仍然有几个现代 *CPU* 系列，它们继承了弱序硬件的传统。

+ ***ARM***：目前在数亿部智能手机和平板电脑中都有，在多核配置中越来越受欢迎。
+ ***PowerPC***：特别是 *Xbox 360* ，已经以多核的配置交付给了 7000 万个家庭。
+ ***Itanium***：微软在 *Windows* 中不再支持它，但 *Linux* 和惠普服务器中仍然支持它。

这些 *CPU* 的内存模型在各种方面几乎与 *Alpha* 的一样弱，除了程序员特别感兴趣的一个常见细节：它们会保证数据的依赖性顺序。这是什么意思？这意味着，如果你在 *C/C++* 中写 `A->B`，你总是可以保证加载一个值 `B`，它至少和 `A` 的值一样新。*Alpha* 却不能保证这一点。我不会在这里过多地讨论数据依赖排序，只是想提一下 *Linux* *RCU* 机制严重依赖它。


## 强内存模型 - *Strong Memmory Models*
---
让我们先看看硬件内存模型。强的和弱的到底有什么区别？在这个问题上实际上[有一点分歧](http://herbsutter.com/2012/08/02/strong-and-weak-hardware-memory-models/#comment-5903)，但我的感觉是，在 80% 的情况下，大多数人的意思是一样的。因此，我想提出以下定义：

	强硬件内存模型是指每条机器指令都隐含地带有获取和释放语义的模型。因此，当一个 CPU 核心执行一系列写操作时，其他 CPU 核心看到这些值的变化顺序与写操作的顺序相同。

这并不难想象。想象一下对“源代码控制类比”的改进，所有修改都按顺序提交给共享内存（写入之间没有重新排序），按顺序从共享内存中提取（读取之间没有重排序），并且指令总是按顺序执行（写相对于读不会重新排序）。然而，读相对于写的重新排序[仍然是可能的](http://preshing.com/20120515/memory-reordering-caught-in-the-act)。

根据上述定义，*x86/64* 系列处理器通常是强序的。在某些情况下，*x86/64* 的一些[强序保证会失效](http://preshing.com/20120913/acquire-and-release-semantics#comment-20810)，但在大多数情况下，作为应用程序程序员，我们可以忽略这些情况。*x86/64* 处理器确实可以[无序执行指令](http://en.wikipedia.org/wiki/Out-of-order_execution)，但这是硬件实现的细节——重要的是它仍然保持其内存交互的有序性，因此在多核环境中，我们仍然可以认为它是强序的。从历史上看，由于[不断发展的规格](http://jakob.engbloms.se/archives/1435)，也有一些混乱。

显然，当以 *TSO* 模式运行时，*SPARC* 处理器是硬件强序的另一个例子。*TSO* 代表“总存储序”，这在某种程度上与我上面给出的定义不同。这意味着所有内核对共享内存的写入总是有一个单一的全局顺序。*x86/64* 也具有此属性：有一些示例，请参阅[英特尔 *x86/64* 体系结构规范第3卷 §8.2.3.6-8](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)。据我所知，*TSO* 属性通常不会引起底层无锁程序员的直接兴趣，但它是朝着顺序一致性迈出的一步。

### 顺序一致性 - *Sequential Consistency*

在[顺序一致](http://preshing.com/20120612/an-introduction-to-lock-free-programming#sequential-consistency)的内存模型中，不存在内存重排序。这就好像整个程序的执行被简化为每个线程指令的顺序交错。如此一来，在 [*Memory Reordering Caught In the Act*](http://preshing.com/20120515/memory-reordering-caught-in-the-act) 里我们不会得到 *r1 = r2 = 0* 结果。

如今，你很难找到能够在硬件级别保证顺序一致性的现代多核设备。然而，早在 1989 年，似乎至少有一种顺序一致的双处理器机器存在：基于 386 的[康柏 *SystemPro*](http://vogons.zetafleet.com/viewtopic.php?t=23842#178666)。根据英特尔的文档，386 还没有先进到可以在运行时执行任何内存重新排序。

在任何情况下，只有在使用高级编程语言时，顺序一致性才真正成为软件内存模型的关注点。在 *Java* 5 及更高版本中，可以将共享变量声明为 `volatile`。在 *C++* 11 中，当对原子库类型执行操作时，可以使用默认的排序约束，即 `memory_order_seq_cst`。如果你这么做了，工具链将限制编译器重新排序，并发出特定于 *CPU* 的指令，这些指令充当适当的内存屏障类型。通过这种方式，即使在弱序多核设备上也可以模拟顺序一致的内存模型。如果你读过 *Herlihy & Shavit* 的《多处理器编程的艺术》，你就会意识到他们的大多数例子都假设了一个顺序一致的软件内存模型。


## 更多细节 - *Further Details*
---
内存模型中还有许多其他微妙的细节，但根据我的经验，在应用程序级别编写无锁代码时，它们并没有那么有趣。比如控制依赖、因果一致性和不同的内存类型。尽管如此，大多数讨论都回到了我在这里概述的四个主要类别。

如果你真的想对处理器内存模型的细节吹毛求疵，并且喜欢将这种形式逻辑的推演当成日常训练，那么你可以查看剑桥大学所做的[令人钦佩的详细工作](http://www.cl.cam.ac.uk/~pes20/weakmemory/)。*Paul McKenney* 写了一篇[通俗易懂的概述](http://lwn.net/Articles/470681/)，介绍了他们的一些工作及其相关工具。