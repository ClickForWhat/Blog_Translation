*本文档译自 blog.molecular-matters.com 的 "Memory System" 系列文章，作者 Stefan Reinalter*


## 概述 - *Overview*
----
在深入研究增长分配器的内部工作之前，我想解释一下虚拟内存的概念，并讨论它是什么，为什么需要它，以及我们可以使用它做什么。


## 什么是虚拟内存 - *What is virtual memory?*
---
简单来说，虚拟内存提供了访问内存时的一个间接途径。它提供了一个进程的虚拟地址空间的抽象，它让每个进程都认为自己在系统中是唯一的。它让我们编写程序时不必担心其他程序分配了哪些内存，也不必担心我们具体需要访问哪些物理内存。尽管虚拟内存经常与对硬盘的分页（以及交换）一起被提到，但这并不是我们感兴趣的。

考虑一个具有 *4GB* 内存的系统，该系统由 4 个物理 *1GB* 内存单元组成。我们能够分配超过 *1GB* 的连续内存，即使实际上并没有大于 *1GB* 的物理内存单元。这要归功于虚拟内存。

类似地，我们在应用程序中进行分配，返回的是在我们的进程中有效的虚拟地址。这样的地址可以是 *0x80000000*，而另一个进程也可以在 *0x80000000* 处拥有分配，但是由于虚拟内存，一切都可以正常工作。


## 地址翻译 - *Address translation*
---
在到达实际的物理内存之前，需要对虚拟地址进行翻译。这个虚拟地址到物理地址的转换由 [*CPU* 的 *MMU*](http://en.wikipedia.org/wiki/Memory_management_unit) 负责。现代 *CPU* 也有一个 [*TLB*](http://en.wikipedia.org/wiki/Translation_lookaside_buffer)，用来加速这种转换。传统上，这种翻译是逐页进行的。这意味着在操作系统级别上，只能在一定大小的所谓的“页”中分配内存。例如，*Windows 7* 的默认页面大小为 *4KB*。因此，这也意味着无论何时直接从操作系统分配内存，都只能按照页面大小粒度进行分配。

地址转换的细节实际上相当复杂，这里有一篇很好的文章描述了 *x86* 和 *Cell* 架构的这个过程：[Memory Address Translation](http://www.altdevblogaday.com/2011/07/24/memory-address-translation/ "Memory Address Translation")。


## 页分配 - *Allocating pages*
---
例如，使用 `VirtualAlloc` （*Windows* 上的低层级分配函数）分配 10 字节的内存，实际将分配整个页面，即 4096 字节。你可以访问这 4096 字节而不会触发访问冲突，即使你只请求了 10 个字节。

当然，不同平台（主机）的页面大小不同。有些平台甚至提供不止 *4KB* 大小的页面。这样做的原因是，由于 *TLB* 的大小通常是有限的，增加页面大小可以减少 *TLB* 丢失（类似于缓存丢失），从而提高性能。然而，如果你不小心，较大的页面也会导致更多的内存浪费。因此，这是一个典型的空间/时间权衡。

通常，操作系统内存分配器（例如 `malloc`/`free`）负责分配页面，将邻近的分配合并到连续区域，将几个小的分配放在同一页面上，等等。然而，一旦我们想要实现自己的通用分配器或任何其他自定义分配方案，我们就需要了解这些细节，并且不能出于我们的目的使用 `malloc`/`free`。

此外，了解这些底层细节使我们能够使用大量新的调试技术，如使用[ *Guard* 页面](http://msdn.microsoft.com/en-us/library/windows/desktop/aa366786%28v=vs.85%29.aspx)、[保护页](http://msdn.microsoft.com/en-us/library/windows/desktop/aa366549%28v=vs.85%29.aspx)等。例如，可以将一些页面标记为只读，以便查找内存重叠、竞争条件（对共享数据的写操作）等等。保护页可作为内存页访问的一次性警报，例如用于增加应用程序堆栈。像 [PageHeap](http://msdn.microsoft.com/en-us/library/windows/hardware/ff549561%28v=vs.85%29.aspx) 这样的应用程序会使用这些特性来查找超出分配边界的内存访问。


## 用例 - *Use cases*
---
*MMU*，*TLB*，页，地址翻译，内存保护......这些听起来很美妙，但是我们能用它们来做什么？

因为操作系统对保留地址空间（`VirtualAlloc` 函数的 *MEM_RESERVER*）和为地址空间分配物理内存（*MEM_COMMIT*）这两种行为分开了，所以我们可以构建可以增长到指定上限的分配器，但只分配它们实际需要的内存。

在实现不断增长的分配器时，这是非常非常有用的，因为我们可以保留一个连续的内存区域（=虚拟地址空间），但只在需要的时候提交物理内存。

所有常见的桌面操作系统（*Windows*，*Linux*，*Mac*），几乎所有的主机（由于保密协议的原因不能详细说明），甚至是手机（如 *iPhone*）都支持虚拟内存寻址。如何在这些平台上使用虚拟内存构建不同的增长型分配器将是下一篇文章的主题。