 *本文档译自 2015 The Android Open Source Project's 中 "Panic.h" 的注释部分*


## 什么是 Panic ? - *What's a Panic?*
----------
在这个文档的上下文中，***panic*** 是指一种违反事先约定的规范而导致的错误。这和使用 ***result*** 或 ***status*** 等概念的代码有所不同。

以下是几条关于 ***panic*** 的定义：
1. 函数未能满足自身的后置条件。所谓“未能满足的后置条件”，例如（但不限于）无法生成有效的返回值对象。通常这样的错误会发生在运行时期，比如可能由运算错误引起，像Ariane 5火箭一样（它坠毁是因为其重复使用了Ariane 4的惯性模块，却没有考虑Ariane 5更大的水平加速度，从而导致计算溢出）。但不能说Ariane 4本身的模块有bug，只是因为此模块使用不当而无法满足后置条件。
2. 未能满足函数的被调用方的前提条件。通俗而言，即函数不能满足它必须调用的另一个函数的前提条件，比如满足其对参数的限制。请注意，不要与函数的先决条件在输入时已被违反的情况相混淆，这通常是编写者自身的编程错误。通常这样的错误可以避免。


## 故障报告与处理 - *Failure reporting vs. handling*
-----
通常，当检测到以上所述的 ***panic*** 时，程序除了终止外别无选择。一般这些情况可以由 `assert()` 处理。然而， `assert()` 自身将两个不同的概念的实施混合到了一起：故障检测和故障处理。然而，检测到故障的地方通常没有足够的上下文信息来决定如何处理此故障。无论如何，至少必须记录故障（ `assert()` 以比较粗糙的方式记录），但是我们还可能需要执行其他操作，例如：
+ 在系统级的范围记录故障。
+ 在开发构建中输出足够的信息以分析/调试问题。
+ 干净地释放一些资源，例如与其他进程的通信信道。（避免其前置或后置条件也被违反）
在某些情况下，故障甚至可能被完全忽略，因为在发生故障的上下文中这可能无关紧要。显然，这样的判断并不总是能在故障现场中确定。所以，将故障检测和处理分开是很重要的。


## 检测和处理设施 - *Failure detection and handling facilities*
----
显然，灾难性的故障是比较罕见的。事实上，除了”未能满足函数的后置条件“，这样的事不应该会发生，这还可能取决于外部因素，而且也同样非常罕见。无论如何，当故障发生时，必须能正确检测和处理。由于 ***panic*** 不那么常见，因此处理机制应当尽可能不引人注目，同时也不能让此类故障被忽视。理想情况下，使用API的程序员应该不需要额外做什么事情来处理此API的故障条件。

此处的 ***panic*** 处理设施的一个重要特点是 ***panic*** 不是函数或者API的一部分。

它有以下的几个优点：
+ 提供简单的检测和报告故障方法。
+ 将故障检测和处理分开。
+ 不会发生检测到故障而不处理的情况。
+ 不会增加API设计的负担。
+ 不增加调用点的开销（视觉开销或其他开销）。
+ 故障检测的性能开销非常小。
+ 在常见的情况下，故障处理几乎没有性能影响。
+ 灵活且可扩展。
由于已经确定故障是罕见的例外情况，因此最好使用 ***assert*** 机制来处理它们，这就是下面的API所提供的。不过，在幕后，它使用 ***C++异常*** 机制将检测和处理分开。

	Note：在不支持或不适用异常的设备上，可以将这些API转换为常规的 std::terminate() 。

```C++
ASSERT_PRECONDITION(condition, format, ...)
ASSERT_POSTCONDITION(condition, format, ...)
ASSERT_ARITHMETIC(condition, format, ...)
ASSERT_DESTRUCTOR(condition, format, ...)
```


## 写出适用 assert 的代码 - *Writing code that can assert*
----
因为我们将故障报告与故障处理分开，所以在编写调用上述宏的代码时需要考虑一些问题（即：程序不会在检测到故障时终止）。

### panic 的使用约定

在函数报告故障情况后，可以提供一些关于程序状态的额外保证。以下四个级别的保证被广泛认可，每一级都是下一级的超集：
1. 函数不会进行 ***assert***。析构函数应该始终如此。
2. 如果函数进行了 ***assert***，程序的状态会回滚到调用此函数之前的状态。
3. 如果函数进行了 ***assert***，程序将处于合法的状态。它可能会进行一些清理工作，但 ***invariants*** 仍会保持原状。
4. 如果函数进行了 ***assert***，程序可能处于不安全的状态：可能会发生资源泄露，内存崩溃， ***invariants*** 失效等故障。

### 构造函数的注意事项

构造函数有些特殊，因为如果在执行时发生故障，则不会调用析构函数（当然不会，因为对象还没有构造完成）。这可能会导致在失败之前在构造函数中分配的资源泄露。但是谢天谢地，有一个很好的C++语法来处理这个情况：

```C++
Foo::Foo(size_t s) try : m_size(s), m_buf(new uint32_t[s]) {
    ASSERT_POSTCONDITION(s & 0xF == 0,
		"object size is %u, but must be multiple of 16", s);
} catch (...) {
	delete [] m_buf;
	// the exception will be automatically re-thrown
}
```

不幸的是，这种用法暴露了 ***panic*** 处理宏的底层，基于异常的实现。因此，最好保持构造函数的简单性。并确保它们不会失败。可以用带有工厂的初始化函数来进行初始化操作。

### 析构函数的注意事项

在C++中，析构函数不能抛出异常，并且由于上述宏在内部使用了异常，所以它们不能再析构函数中使用。这样做会导致 `std::terminate()` 立刻终止程序。因此，最好始终保证析构函数不会失败。如果析构函数中出现这样的错误，可以使用 **ASSERT_DESTRUCTOR()** 宏，它会记录错误，但不会终止程序，而是会像什么都没发生一样继续执行。当然，这通常会导致一些资源泄露，最终导致产生另一个错误（一般会是后置条件未满足）。

这样做的理由是，在C++中根本无法从析构函数报告故障，暴力终止其过程是不适当的，因为它再次将故障报告和处理混为一谈。例如，`glDeleteTextures()` 中的失败不一定致命（无论其是否保存了用户的数据）。另一种选择是让调用者自行承担失败，但是这也不太好，因为失败会被忽略。这里保留的解决方案是妥协。

### 在你的代码使用 panic

由于 ***panic*** 在其底层实现中使用异常，你可以通过执行以下操作来测试使用`EXPECT_THROW`的代码：
1. 设置 ***panic*** 模式来抛出错误（默认是 `TERMINATE` ）。
2. 将 ***panic*** 作为异常传递给 `EXPECT_THROW`。
示例代码如下：

```C++
// since your code uses panics, this should include utils/Panic.hpp
#include <MyClass.hpp>  
 
using utils::Panic;
TEST(MyClassTest, value_that_causes_panic) {
	EXPECT_THROW(MyClass::function(value_that_causes_panic), Panic);
}
// ... other tests ...
int main(int argc, char** argv) {
	::testing::InitGoogleTest(&argc, argv);
	Panic::setMode(Panic::Mode::THROW);
	return RUN_ALL_TESTS();
}
```