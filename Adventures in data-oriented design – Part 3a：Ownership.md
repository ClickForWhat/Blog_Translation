*本文档译自 blog.molecular-matters.com 的 "Adventures in data-oriented design" 系列文章，作者 Stefan Reinalter*


## 概述 - *Overview*
----
我在开发 *Molecule* 引擎的过程中注意到一件事：明确定义数据的所有权可以极大地帮助你遵循面向数据的设计方法，反之亦然。

定义所有权最初要求人们更多地考虑谁拥有数据，谁负责创建和销毁实例，但从维护、性能和可调试性方面来说，这也是非常值得的。我想回到我最喜欢的一个例子，因为每个人都很容易理解：渲染一堆静态网格。


## 渲染网格 - *Mesh rendering*
----
我们要看的例子有下面几个：

+ 一个包含了任意数量的静态网格的关卡。静态网格由顶点缓冲区、索引缓冲区和一组三角形组组成，这些三角形组包含网格中每个组/子网格使用的索引。我们将保存这些信息的结构或类称为网格。
+ 每个网格都可以使用不同的着色器和材质来渲染，因此它们不是网格的一部分，而是被称为*MeshInstance*、*MeshComponent* 或类似的东西。我们需要这种划分，因为同一个网格可以在一个关卡中多次使用不同的着色器和材质进行实例化。

如果你不太关心内存、性能和你同事的精神状态，最简单的解决方案是使用 *new* 为每个 *Mesh* 单独分配内存，并在 *MeshInstance* 中存储一个指向 *Mesh* 的指针。因为现在允许多个 *MeshInstance* 引用同一个 *Mesh*，所以你可以让这个指针变成 `shared_ptr<Mesh>` 或类似的东西，或者在 *Mesh* 类中自己设计一些其他的引用计数方法，并存储一个普通的原始指针。当你这样做的时候，顶点缓冲区和索引缓冲区也应该是引用计数的，因为你可以这样做，并且这样做也不错。以 *OOP* 风格解决了问题。

嗯，确实，不错。但，也没那么不错。

使用这种方法有几个主要的缺点：

+ **所有权**：谁会拥有 *Mesh* 的实例？每当一个 *MeshInstance* 被删除或超出作用域时，它只会减少被引用对象的引用计数。有人能指出对象什么时候会被销毁吗？顶点缓冲区和索引缓冲区也是如此。具体会在什么时候被销毁？
+ **性能**：你向此类的用户传递裸指针、`shared_ptr<>` 或者类似的东西。这使得在内存中移动内容非常困难（如果可能的话），并且要让所有传递出去的指针仍然指向正确的对象。因此，你的大多数对象都分散在堆中，在访问它们时将导致大量的缓存丢失，因为子系统无法以最适合它们运作的方式重新排列这些对象。
+ **可调试性**：裸指针马上就会变成恐怖的悬空指针（悬空指针：“很快就到你家门口！”）。哦，你正确地释放了一个 *Mesh* 引用，原始对象被销毁了，不过你还存着你的 *MeshInstance*？好吧，内存管理器同时在内存中的相同位置分配了一个新实例，你现在正在使用和预期完全不同的数据，而没有注意到。看来今天不是你的 *lucky day*。

我们当然可以做得更好。


## 更好的解决方案 - *A better solution*
----
首先要考虑的是：谁使用数据，谁会拥有数据、谁会创建和销毁数据？让我们先看看顶点缓冲区和索引缓冲区。

渲染引擎中唯一应该做API调用的是渲染后端（*render backend*）。按 *Molecule* 的术语解释，渲染后端只是一个带有大量非成员函数的命名空间，这些函数直接与 *D3D11*、*OpenGL*、*DX9* 或其他API联系起来。移植图形模块意味着移植后端，并额外暴露特定于平台的功能，仅此而已。

后端还负责根据64位的键对 *draw call* 进行排队和排序，因此是引擎中唯一能绑定顶点缓冲区、设置渲染状态、执行实际绘制调用等的地方。

因为后端是唯一接触这些数据的地方，所以如果所有与渲染相关的低级数据（如顶点和索引缓冲区）在内存中尽可能靠近，它将受益最大。因此，后端本身也应该负责创建/销毁这些缓冲区，并接管它们的所有权。

此外，我们不希望返回裸指针到内部的其他地方，因为我们希望能够跟踪对过期数据的访问，消灭悬空指针！更近一步，通过给用户一个简单的标识符，例如一个整数而不是一个指针，“我是否拥有它？我需要释放这个吗？”这类的问题将彻底消失。


## 简单胜过一切 - *Simplicity trumps everything*
----
那么，在内存中获得尽可能彼此靠近的数据的最简单解决方案是什么呢？一个数组。

这就是 *Molecule* 所使用的办法。渲染后端保存了一个包含4096个顶点缓冲区和4096个索引缓冲区的数组。当然，这些数字是可配置的，但你是否需要在同一时间 ***flight*** 超过4k个顶点缓冲区？如果是这样，最坏的情况是在某一帧中至少有4k个不同的绘制调用，这无论如何（就性能而言）都是不合理的。

你现在可以简单地返回一个16位整数而不是指针，可以用来唯一地识别数组中的顶点和索引缓冲区，它只不过是数组的一个索引。不仅所有权问题不再是一个问题（毕竟你不能 `delete` 或 `free()` 一个16位整数，也不能减少其引用计数），你还可以构建一个机制来跟踪给定的整数是否引用了一个现有的对象，这就是通常所说的[句柄](http://gamesfromwithin.com/managing-data-relationships)。取决于实例的最大数量，16位 *int* 可能就足够了，当然你也可以使用32位。

也就是说，在 *Molecule* 中创建和销毁顶点和索引缓冲区的接口是这样的：

```C++
namespace backend
{
	VertexBufferHandle CreateVertexBuffer(
	unsigned int vertexCount, unsigned int stride, const void* initialData);
	
	VertexBufferHandle CreateDynamicVertexBuffer(
	unsigned int vertexCount, unsigned int stride);
	
	void DestroyVertexBuffer(VertexBufferHandle handle);
	 
	IndexBufferHandle CreateIndexBuffer(
	unsigned int indexCount, IndexBuffer::Format::Enum format, const void* initialData);
	
	void DestroyIndexBuffer(IndexBufferHandle handle);
}
```


## 引用网格数据 - *Referencing mesh data*
----
考虑到网格数据所有权，我们也可以想出一个类似的简单解决方案来引用/存储这些数据。

在 *Molecule* 引擎中，一个称为 *render world* 的东西保存着与图形模块相关的所有数据，主要是从资源包中提取的内容，如网格、骨骼、动画、粒子系统、图形相关组件等。

类似于由渲染后端保存着固定大小的顶点和索引缓冲区，*render world* 存储了一个数组，它存储着资源包中包含的所有网格。所有其他与渲染相关的数据也属于 *render world*，所以我们也可以通过使用句柄来引用它们。

这意味着 *Mesh* 现在看起来像这样：

```C++
struct Mesh
{
	VertexBufferHandle m_vertexBuffer;
	IndexBufferHandle m_indexBuffer;
	TriangleGroupHandle m_triangleGroups;
	uint16_t m_triangleGroupCount;
};
```

没有引用计数，没有 `shared_ptr<>`，没有裸指针。`Mesh` 可以平凡复制，并且可以通过使用 `memcpy()` 在内存中移动。

你如何持有一个 *Mesh*？*MeshInstance* 长什么样子？这些问题现在有个很简单的答案：只需要复制网格。你只需复制一个 *Mesh* 就可以持有它。*MeshComponent* 仅仅简单存储了一个 *Mesh* 的拷贝，以及着色器、材质之类的类似的句柄。

实际上，*MeshComponents* 本身是被负责渲染它们的渲染系统所持有的，但这是另一篇博客文章的内容了。


## 结语 - *Conclusion*
----
让我们快速回顾一下：

+ 顶点和索引缓冲区由渲染后端拥有。不会有裸指针被传递到外部，只有句柄。句柄是一种不透明的数据类型，用户不会（也不应该）知道如何解释给定的整数。
+ *MeshInstance* 属于 *render world*。通过复制 *Mesh* 可以简单地引用它们，这样就可以为你提供所需的所有数据，以便对其进行处理。
+ 没有引用计数机制，没有裸指针，最重要的是没有悬空指针。系统会自动识别对过期数据的访问。此外，大多数句柄占用的内存比指针少，尤其是在64位系统上。
+ *MeshInstance*、*MeshComponents* 和许多其他类似的东西只是数据容器，因此可以在内存中自由移动，而不必担心所有权、构造/删除等问题。

在接下来的文章中，我们将更深入地了解 *Molecule* 如何引用由子系统在内存中移动的数据，这些子系统主要负责更新/渲染。其中一个系统是负责渲染网格的系统，在那里，以缓存友好的方式访问数据至关重要。具体来说，我们将详细介绍内部引用（= *handles*）和外部引用（= *IDs*）。
