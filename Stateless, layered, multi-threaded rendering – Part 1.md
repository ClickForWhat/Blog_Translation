*本文档译自 blog.molecular-matters.com 的 "Stateless, layered, multi-threaded rendering" 系列文章，作者 Stefan Reinalter*


## 概述 - *Overview*
----
在这篇文章中，我想说说我打算支持哪些现代渲染系统的功能和性能特征：它应该支持无状态渲染、在不同 *layer*/*bucket* 中执行渲染，以及可以在尽可能多的内核上并行它。

最近，我一直在思考如何有效地实现这样一个渲染系统，并想在我去实现整个系统之前，记录、分享我到目前为止的想法和发现。


## 渲染后端 - *Rendering backend*
----
渲染后端是什么意思？在我看来，渲染后端应该只负责一件事：使用 *D3D* 或 *OpenGL* 等图形API提交绘制调用。更高级的这类系统的职责是确保只进行最少数量的 *draw call* 调用，并对绘制调用和状态更改进行排序和优化。


## 无状态渲染 - *Stateless rendering*
----
我们通常处理的所有图形API都是有状态的。这意味着，每当你为某个绘制调用更改API中的任何状态时，这种状态更改也会影响之后提交的绘制调用。例如，如果将某个对象的剔除状态从背面更改为正面剔除，则需要在此对象完成渲染后重置状态，或者为所有其他对象设置默认状态，否则某些对象最终会以错误的剔除状态进行渲染。

向用户公开这样一个有状态的API很容易出错，而且这是一个糟糕的抽象。理想情况下，无论我们想要什么状态，提交一个 *draw call* 都不应该影响任何其他的 *draw call*。这将使我们能够将每个单独的 *draw call* 视为一个携带所有所需状态的单个“东西”，而不会将其任何状态泄漏到其他 *draw call* 中。

这也使我们能够轻松地更改 *draw call* 的顺序（只要渲染结果保持不变），使我们能够摆脱多余的状态更改，并按某个属性（例如距离从近到远、从远到近或其他的一些标准）对绘制调用进行排序。

《文明V》中使用的 [*Firaxis‘LORE*](http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/Firaxis%20LORE.pps) 系统的演讲对此介绍得更加详细。


## 层级渲染 - *Layered rendering*
----
也称为 *Bucketized Rendering*，意思是为 *draw call* 分配一个值（译注：下称“键”），然后根据某种规则用于排序。通常，它只是一个32位或64位的整数，仅此而已。一般会将绘制调用的某些数据（如距离、材质、着色器等）编码到这个整数的某一个位中，然后根据这些位在整数中的位置，你可以对不同的 *draw call* 数组应用不同的排序标准（译注：例如不透明物体按由近到远，半透明物体按由远到近），只要你知道这个键是如何构建的。

这是一种非常有效和直接的方法，因为你可以对这个整数使用简单的基数排序，而不必担心如何对数据排序（是按距离排序呢？纹理？还是通过材质？）。排序规则基本上是按整数的位来进行的，如果你想按材料而不是按距离排序，只需要把各自的位放在不同的位置。

[*Christer Ericson*](http://realtimecollisiondetection.net/blog/?p=86 "Order your draw calls") 的博客很好地解释了这个概念，如果你不熟悉的话。

不过，与 *Christer* 的方法相比，有一件事我最有可能采取不同的做法。我认为渲染器本身（例如， *Deferred* 渲染器， *Clustered* 渲染器， *Forward+* 渲染器）既然知道如何渲染实体，因此也应该知道它需要渲染多少层和渲染哪些层。

例如，一个简单的 *Deferred* 渲染器首先将对象渲染到 *G-Buffer*，然后渲染贴花，然后为每个光源投射的阴影绘制阴影贴图，接着逐个应用所有光照，使用前向渲染半透明对象，最后是 *HUD* 元素和类似的东西。当然，可能有几十种不同的实现，但你可以理解。

我的想法是，我不会把每个层的每个 *draw call* 都塞进相同大小的键中，再将它们都存储在一个大的数据流中（或每个线程的本地数据流），而是为不同的层使用不同大小的键。例如，渲染阴影贴图时，对象应该从前到后排序，而不需要按材质或着色器排序。因此，单个16位整数可能就足够根据到相机的距离进行粗略的前后排序了。因此，我将把这些16位的键放到不同的 *bucket* 中，而不是包含其他层的绘制调用。

我可能采用16位的键，用于阴影贴图的 *bucket*，半透明对象的 *bucket* 用32位键，生成 *G-Buffer* 的 *bucket* 用64位键。这里的想法是，较小的数据可以更快地排序，并且可以在不同线程上对不同的 *bucket* 并行排序。


## 多线程渲染 - *Multi-threaded rendering*
----
使用这样一个 *layered/bucketized* 的系统，我们得到的一大好处当然是能够使用所有可用的线程进行渲染。常见的方法是将所有 *draw call* 编码成键存入到整个帧的 *layer/bucket* 容器中，按键排序，然后使用前面提到的渲染后端将它们提交给图形API。虽然图形API调用只能从主线程完成，但对 *draw call* 进行排队可以很容易地并行完成。

如果引擎遵循面向数据的设计方法，或者使用任务调度器，则每个核心一次可以在N个给定的实体上工作，可能将其工作拆分为几个任务，然后交给调度器。我可能会使用一种类似于 [*Bitsquid* 引擎](http://www.bitsquid.se/presentations/flexible-rendering-multiple-platforms.pdf)使用的方法：将 *draw call* 数据存储在每个线程的本地数据流中，然后在主线程上提交之前对其进行排序和合并，而不是将所有 *draw call* 及其键存储在一个数据流中。


## 总结想法 - *General thoughts*
----
最后还有一个关于渲染的想法：实体的渲染应该通过将 *draw call* 存入各个独立的 *bucket* 来实现，而不是从每个 *bucket* 里的每个实体中提取状态。

更具体地说，不是这样做：

```C++
for each (bucket b)
{
	for each (entity e)
	{
		submit_draw_call_to_bucket(b, get_draw_call(e, b));
	}
}
```

而是这样做：

```C++
for each (entity e)
{
	submit_draw_call_to_bucket(BucketType::shadow_map, e);
	submit_draw_call_to_bucket(BucketType::g_buffer, e);
	...
}
```

这对一些人来说可能不值一提，但我认为值得指出。毕竟，仍然有很多人通过遍历 `std::vector` 来渲染一组 *GameObjects*，并为每个对象调用 `render()` 虚方法。这本身没有错，但你不会想用第一种方法来做一个有数百个实体的游戏。

确保我们每帧只接触一个实体一次，并把其 *draw call* 放到不同的 *bucket* 中（而不是多次访问同一实体），如果你有很多实体，这会在性能上产生差异。

今天就到这里！我希望在下周四之前能有更多的东西可以分享，甚至有一些代码可以看！